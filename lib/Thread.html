<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=US-ASCII" http-equiv="Content-Type">

<title>class Thread - RDoc Documentation</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>thread.c
    <li>vm.c
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link"><a href="Object.html">Object</a>
  
</nav>

    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li  ><a href="#method-c-DEBUG">::DEBUG</a>
    
    <li  ><a href="#method-c-DEBUG-3D">::DEBUG=</a>
    
    <li  ><a href="#method-c-abort_on_exception">::abort_on_exception</a>
    
    <li  ><a href="#method-c-abort_on_exception-3D">::abort_on_exception=</a>
    
    <li  ><a href="#method-c-current">::current</a>
    
    <li  ><a href="#method-c-exit">::exit</a>
    
    <li  ><a href="#method-c-fork">::fork</a>
    
    <li  ><a href="#method-c-kill">::kill</a>
    
    <li  ><a href="#method-c-list">::list</a>
    
    <li  ><a href="#method-c-main">::main</a>
    
    <li  ><a href="#method-c-pass">::pass</a>
    
    <li  ><a href="#method-c-start">::start</a>
    
    <li  ><a href="#method-c-stop">::stop</a>
    
    <li  ><a href="#method-i-5B-5D">#[]</a>
    
    <li  ><a href="#method-i-5B-5D-3D">#[]=</a>
    
    <li  ><a href="#method-i-abort_on_exception">#abort_on_exception</a>
    
    <li  ><a href="#method-i-abort_on_exception-3D">#abort_on_exception=</a>
    
    <li  ><a href="#method-i-add_trace_func">#add_trace_func</a>
    
    <li  ><a href="#method-i-alive-3F">#alive?</a>
    
    <li  ><a href="#method-i-backtrace">#backtrace</a>
    
    <li  ><a href="#method-i-exit">#exit</a>
    
    <li  ><a href="#method-i-group">#group</a>
    
    <li  ><a href="#method-i-inspect">#inspect</a>
    
    <li  ><a href="#method-i-join">#join</a>
    
    <li  ><a href="#method-i-key-3F">#key?</a>
    
    <li  ><a href="#method-i-keys">#keys</a>
    
    <li  ><a href="#method-i-kill">#kill</a>
    
    <li  ><a href="#method-i-priority">#priority</a>
    
    <li  ><a href="#method-i-priority-3D">#priority=</a>
    
    <li  ><a href="#method-i-raise">#raise</a>
    
    <li  ><a href="#method-i-run">#run</a>
    
    <li  ><a href="#method-i-safe_level">#safe_level</a>
    
    <li  ><a href="#method-i-set_trace_func">#set_trace_func</a>
    
    <li  ><a href="#method-i-status">#status</a>
    
    <li  ><a href="#method-i-stop-3F">#stop?</a>
    
    <li  ><a href="#method-i-terminate">#terminate</a>
    
    <li  ><a href="#method-i-value">#value</a>
    
    <li  ><a href="#method-i-wakeup">#wakeup</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="./ext/syslog/syslog_txt.html">syslog</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li style="background: #ffc;"><a href="./Digest.html">Digest</a>
  
    <li style="background: #ffc;"><a href="./Digest/Base.html">Digest::Base</a>
  
    <li ><a href="./Digest/Class.html">Digest::Class</a>
  
    <li style="background: #ffc;"><a href="./Digest/HMAC.html">Digest::HMAC</a>
  
    <li ><a href="./Digest/Instance.html">Digest::Instance</a>
  
    <li style="background: #ffc;"><a href="./Digest/SHA2.html">Digest::SHA2</a>
  
    <li ><a href="./Encoding.html">Encoding</a>
  
    <li ><a href="./Encoding/CompatibilityError.html">Encoding::CompatibilityError</a>
  
    <li ><a href="./Encoding/Converter.html">Encoding::Converter</a>
  
    <li ><a href="./Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a>
  
    <li ><a href="./Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
  
    <li ><a href="./Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a>
  
    <li style="background: #ffc;"><a href="./Process.html">Process</a>
  
    <li ><a href="./Process/GID.html">Process::GID</a>
  
    <li ><a href="./Process/Status.html">Process::Status</a>
  
    <li ><a href="./Process/Sys.html">Process::Sys</a>
  
    <li ><a href="./Process/UID.html">Process::UID</a>
  
    <li ><a href="./Socket.html">Socket</a>
  
    <li ><a href="./Socket/AncillaryData.html">Socket::AncillaryData</a>
  
    <li ><a href="./Socket/Option.html">Socket::Option</a>
  
    <li ><a href="./Socket/UDPSource.html">Socket::UDPSource</a>
  
    <li ><a href="./Enumerator.html">Enumerator</a>
  
    <li ><a href="./Enumerator/Generator.html">Enumerator::Generator</a>
  
    <li ><a href="./Enumerator/Yielder.html">Enumerator::Yielder</a>
  
    <li style="background: #ffc;"><a href="./File.html">File</a>
  
    <li ><a href="./File/Constants.html">File::Constants</a>
  
    <li ><a href="./File/Stat.html">File::Stat</a>
  
    <li style="background: #ffc;"><a href="./IO.html">IO</a>
  
    <li ><a href="./IO/WaitReadable.html">IO::WaitReadable</a>
  
    <li ><a href="./IO/WaitWritable.html">IO::WaitWritable</a>
  
    <li ><a href="./RubyVM.html">RubyVM</a>
  
    <li ><a href="./RubyVM/Env.html">RubyVM::Env</a>
  
    <li ><a href="./RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a>
  
    <li style="background: #ffc;"><a href="./GC.html">GC</a>
  
    <li ><a href="./GC/Profiler.html">GC::Profiler</a>
  
    <li style="background: #ffc;"><a href="./Math.html">Math</a>
  
    <li ><a href="./Math/DomainError.html">Math::DomainError</a>
  
    <li style="background: #ffc;"><a href="./Syslog.html">Syslog</a>
  
    <li ><a href="./Syslog/Constants.html">Syslog::Constants</a>
  
    <li ><a href="./ARGF.html">ARGF</a>
  
    <li ><a href="./Addrinfo.html">Addrinfo</a>
  
    <li style="background: #ffc;"><a href="./ArgumentError.html">ArgumentError</a>
  
    <li style="background: #ffc;"><a href="./Array.html">Array</a>
  
    <li style="background: #ffc;"><a href="./BasicObject.html">BasicObject</a>
  
    <li style="background: #ffc;"><a href="./BasicSocket.html">BasicSocket</a>
  
    <li ><a href="./Bignum.html">Bignum</a>
  
    <li ><a href="./Binding.html">Binding</a>
  
    <li style="background: #ffc;"><a href="./Class.html">Class</a>
  
    <li style="background: #ffc;"><a href="./Comparable.html">Comparable</a>
  
    <li ><a href="./Complex.html">Complex</a>
  
    <li ><a href="./Continuation.html">Continuation</a>
  
    <li ><a href="./Data.html">Data</a>
  
    <li style="background: #ffc;"><a href="./Dir.html">Dir</a>
  
    <li style="background: #ffc;"><a href="./ENV.html">ENV</a>
  
    <li style="background: #ffc;"><a href="./EOFError.html">EOFError</a>
  
    <li style="background: #ffc;"><a href="./EncodingError.html">EncodingError</a>
  
    <li style="background: #ffc;"><a href="./Enumerable.html">Enumerable</a>
  
    <li style="background: #ffc;"><a href="./Errno.html">Errno</a>
  
    <li style="background: #ffc;"><a href="./Exception.html">Exception</a>
  
    <li style="background: #ffc;"><a href="./FalseClass.html">FalseClass</a>
  
    <li ><a href="./Fiber.html">Fiber</a>
  
    <li ><a href="./FiberError.html">FiberError</a>
  
    <li ><a href="./FileTest.html">FileTest</a>
  
    <li style="background: #ffc;"><a href="./Fixnum.html">Fixnum</a>
  
    <li style="background: #ffc;"><a href="./Float.html">Float</a>
  
    <li style="background: #ffc;"><a href="./FloatDomainError.html">FloatDomainError</a>
  
    <li style="background: #ffc;"><a href="./Hash.html">Hash</a>
  
    <li style="background: #ffc;"><a href="./IOError.html">IOError</a>
  
    <li style="background: #ffc;"><a href="./IPAddr.html">IPAddr</a>
  
    <li style="background: #ffc;"><a href="./IPSocket.html">IPSocket</a>
  
    <li style="background: #ffc;"><a href="./IndexError.html">IndexError</a>
  
    <li style="background: #ffc;"><a href="./Integer.html">Integer</a>
  
    <li ><a href="./Interrupt.html">Interrupt</a>
  
    <li style="background: #ffc;"><a href="./Kernel.html">Kernel</a>
  
    <li style="background: #ffc;"><a href="./KeyError.html">KeyError</a>
  
    <li ><a href="./LoadError.html">LoadError</a>
  
    <li style="background: #ffc;"><a href="./LocalJumpError.html">LocalJumpError</a>
  
    <li ><a href="./Marshal.html">Marshal</a>
  
    <li style="background: #ffc;"><a href="./MatchData.html">MatchData</a>
  
    <li ><a href="./Method.html">Method</a>
  
    <li style="background: #ffc;"><a href="./Module.html">Module</a>
  
    <li ><a href="./Mutex.html">Mutex</a>
  
    <li style="background: #ffc;"><a href="./NameError.html">NameError</a>
  
    <li style="background: #ffc;"><a href="./NilClass.html">NilClass</a>
  
    <li ><a href="./NoMemoryError.html">NoMemoryError</a>
  
    <li style="background: #ffc;"><a href="./NoMethodError.html">NoMethodError</a>
  
    <li style="background: #ffc;"><a href="./NotImplementedError.html">NotImplementedError</a>
  
    <li style="background: #ffc;"><a href="./Numeric.html">Numeric</a>
  
    <li style="background: #ffc;"><a href="./Object.html">Object</a>
  
    <li ><a href="./ObjectSpace.html">ObjectSpace</a>
  
    <li style="background: #ffc;"><a href="./Proc.html">Proc</a>
  
    <li ><a href="./Random.html">Random</a>
  
    <li style="background: #ffc;"><a href="./Range.html">Range</a>
  
    <li style="background: #ffc;"><a href="./RangeError.html">RangeError</a>
  
    <li ><a href="./Rational.html">Rational</a>
  
    <li style="background: #ffc;"><a href="./Regexp.html">Regexp</a>
  
    <li style="background: #ffc;"><a href="./RegexpError.html">RegexpError</a>
  
    <li ><a href="./Ripper.html">Ripper</a>
  
    <li style="background: #ffc;"><a href="./RuntimeError.html">RuntimeError</a>
  
    <li ><a href="./SOCKSSocket.html">SOCKSSocket</a>
  
    <li style="background: #ffc;"><a href="./ScriptError.html">ScriptError</a>
  
    <li ><a href="./SecurityError.html">SecurityError</a>
  
    <li ><a href="./Signal.html">Signal</a>
  
    <li ><a href="./SignalException.html">SignalException</a>
  
    <li ><a href="./SocketError.html">SocketError</a>
  
    <li style="background: #ffc;"><a href="./StandardError.html">StandardError</a>
  
    <li ><a href="./StopIteration.html">StopIteration</a>
  
    <li style="background: #ffc;"><a href="./String.html">String</a>
  
    <li style="background: #ffc;"><a href="./Struct.html">Struct</a>
  
    <li style="background: #ffc;"><a href="./Symbol.html">Symbol</a>
  
    <li style="background: #ffc;"><a href="./SyntaxError.html">SyntaxError</a>
  
    <li style="background: #ffc;"><a href="./SystemCallError.html">SystemCallError</a>
  
    <li ><a href="./SystemExit.html">SystemExit</a>
  
    <li ><a href="./SystemStackError.html">SystemStackError</a>
  
    <li ><a href="./TCPServer.html">TCPServer</a>
  
    <li style="background: #ffc;"><a href="./TCPSocket.html">TCPSocket</a>
  
    <li ><a href="./Thread.html">Thread</a>
  
    <li ><a href="./ThreadError.html">ThreadError</a>
  
    <li ><a href="./ThreadGroup.html">ThreadGroup</a>
  
    <li style="background: #ffc;"><a href="./Time.html">Time</a>
  
    <li style="background: #ffc;"><a href="./TrueClass.html">TrueClass</a>
  
    <li style="background: #ffc;"><a href="./TypeError.html">TypeError</a>
  
    <li style="background: #ffc;"><a href="./UDPSocket.html">UDPSocket</a>
  
    <li ><a href="./UNIXServer.html">UNIXServer</a>
  
    <li style="background: #ffc;"><a href="./UNIXSocket.html">UNIXSocket</a>
  
    <li ><a href="./UnboundMethod.html">UnboundMethod</a>
  
    <li ><a href="./ZeroDivisionError.html">ZeroDivisionError</a>
  
    <li ><a href="./fatal.html">fatal</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class"  >class Thread</h1>

  <div style="background: #ddd;">
    
            <span  >DEBUG</span>
    
            <span  >DEBUG=</span>
    
            <span  >abort_on_exception</span>
    
            <span  >abort_on_exception=</span>
    
            <span  >current</span>
    
            <span  >exit</span>
    
            <span  >fork</span>
    
            <span  >kill</span>
    
            <span  >list</span>
    
            <span  >main</span>
    
            <span  >pass</span>
    
            <span  >start</span>
    
            <span  >stop</span>
    
            <span  >[]</span>
    
            <span  >[]=</span>
    
            <span  >abort_on_exception</span>
    
            <span  >abort_on_exception=</span>
    
            <span  >add_trace_func</span>
    
            <span  >alive?</span>
    
            <span  >backtrace</span>
    
            <span  >exit</span>
    
            <span  >group</span>
    
            <span  >inspect</span>
    
            <span  >join</span>
    
            <span  >key?</span>
    
            <span  >keys</span>
    
            <span  >kill</span>
    
            <span  >priority</span>
    
            <span  >priority=</span>
    
            <span  >raise</span>
    
            <span  >run</span>
    
            <span  >safe_level</span>
    
            <span  >set_trace_func</span>
    
            <span  >status</span>
    
            <span  >stop?</span>
    
            <span  >terminate</span>
    
            <span  >value</span>
    
            <span  >wakeup</span>
    
  </div>

  <div id="description" class="description">
    
<p>::VM</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-DEBUG" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            DEBUG     &rarr; num
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the thread debug level.  Available only if compiled with
THREAD_DEBUG=-1.</p>
          

          
          <div class="method-source-code" id="DEBUG-source">
            <pre>static VALUE
rb_thread_s_debug(void)
{
    return INT2NUM(rb_thread_debug_enabled);
}</pre>
          </div><!-- DEBUG-source -->
          
        </div>

        

        
      </div><!-- DEBUG-method -->

    
      <div id="method-c-DEBUG-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            DEBUG = num
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets the thread debug level.  Available only if compiled with
THREAD_DEBUG=-1.</p>
          

          
          <div class="method-source-code" id="DEBUG-3D-source">
            <pre>static VALUE
rb_thread_s_debug_set(VALUE self, VALUE val)
{
    rb_thread_debug_enabled = RTEST(val) ? NUM2INT(val) : 0;
    return val;
}</pre>
          </div><!-- DEBUG-3D-source -->
          
        </div>

        

        
      </div><!-- DEBUG-3D-method -->

    
      <div id="method-c-abort_on_exception" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            abort_on_exception   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the status of the global "abort on exception" condition.  The
default is <code>false</code>. When set to <code>true</code>, or if the
global <code>$DEBUG</code> flag is <code>true</code> (perhaps because the
command line option <code>-d</code> was specified) all threads will abort
(the process will <code>exit(0)</code>) if an exception is raised in any
thread. See also <code>Thread::abort_on_exception=</code>.</p>
          

          
          <div class="method-source-code" id="abort_on_exception-source">
            <pre>static VALUE
rb_thread_s_abort_exc(void)
{
    return GET_THREAD()-&gt;vm-&gt;thread_abort_on_exception ? Qtrue : Qfalse;
}</pre>
          </div><!-- abort_on_exception-source -->
          
        </div>

        

        
      </div><!-- abort_on_exception-method -->

    
      <div id="method-c-abort_on_exception-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            abort_on_exception= boolean   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When set to <code>true</code>, all threads will abort if an exception is
raised. Returns the new state.</p>

<pre>Thread.abort_on_exception = true
t1 = Thread.new do
  puts  &quot;In new thread&quot;
  raise &quot;Exception from thread&quot;
end
sleep(1)
puts &quot;not reached&quot;</pre>

<p><em>produces:</em></p>

<pre>In new thread
prog.rb:4: Exception from thread (RuntimeError)
 from prog.rb:2:in `initialize'
 from prog.rb:2:in `new'
 from prog.rb:2</pre>
          

          
          <div class="method-source-code" id="abort_on_exception-3D-source">
            <pre>static VALUE
rb_thread_s_abort_exc_set(VALUE self, VALUE val)
{
    rb_secure(4);
    GET_THREAD()-&gt;vm-&gt;thread_abort_on_exception = RTEST(val);
    return val;
}</pre>
          </div><!-- abort_on_exception-3D-source -->
          
        </div>

        

        
      </div><!-- abort_on_exception-3D-method -->

    
      <div id="method-c-current" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            current   &rarr; thread
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the currently executing thread.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>   <span class="ruby-comment">#=&gt; #&lt;Thread:0x401bdf4c run&gt;</span>
</pre>
          

          
          <div class="method-source-code" id="current-source">
            <pre>static VALUE
thread_s_current(VALUE klass)
{
    return rb_thread_current();
}</pre>
          </div><!-- current-source -->
          
        </div>

        

        
      </div><!-- current-method -->

    
      <div id="method-c-exit" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            exit   &rarr; thread
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Terminates the currently running thread and schedules another thread to be
run. If this thread is already marked to be killed, <code>exit</code>
returns the <code>Thread</code>. If this is the main thread, or the last
thread, exit the process.</p>
          

          
          <div class="method-source-code" id="exit-source">
            <pre>static VALUE
rb_thread_exit(void)
{
    return rb_thread_kill(GET_THREAD()-&gt;self);
}</pre>
          </div><!-- exit-source -->
          
        </div>

        

        
      </div><!-- exit-method -->

    
      <div id="method-c-fork" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            start([args]*) {|args| block }   &rarr; thread
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            fork([args]*) {|args| block }    &rarr; thread
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Basically the same as <code>Thread::new</code>. However, if class
<code>Thread</code> is subclassed, then calling <code>start</code> in that
subclass will not invoke the subclass's <code>initialize</code> method.</p>
          

          
          <div class="method-source-code" id="fork-source">
            <pre>static VALUE
thread_start(VALUE klass, VALUE args)
{
    return thread_create_core(rb_thread_alloc(klass), args, 0);
}</pre>
          </div><!-- fork-source -->
          
        </div>

        

        
      </div><!-- fork-method -->

    
      <div id="method-c-kill" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            kill(thread)   &rarr; thread
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Causes the given <em>thread</em> to exit (see <code>Thread::exit</code>).</p>

<pre class="ruby"><span class="ruby-identifier">count</span> = <span class="ruby-value">0</span>
<span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">loop</span> { <span class="ruby-identifier">count</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> } }
<span class="ruby-identifier">sleep</span>(<span class="ruby-value">0.1</span>)       <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">kill</span>(<span class="ruby-identifier">a</span>)   <span class="ruby-comment">#=&gt; #&lt;Thread:0x401b3d30 dead&gt;</span>
<span class="ruby-identifier">count</span>            <span class="ruby-comment">#=&gt; 93947</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">alive?</span>         <span class="ruby-comment">#=&gt; false</span>
</pre>
          

          
          <div class="method-source-code" id="kill-source">
            <pre>static VALUE
rb_thread_s_kill(VALUE obj, VALUE th)
{
    return rb_thread_kill(th);
}</pre>
          </div><!-- kill-source -->
          
        </div>

        

        
      </div><!-- kill-method -->

    
      <div id="method-c-list" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            list   &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array of <code>Thread</code> objects for all threads that are
either runnable or stopped.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">sleep</span>(<span class="ruby-value">200</span>) }
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-value">1000000</span>.<span class="ruby-identifier">times</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>*<span class="ruby-identifier">i</span> } }
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">stop</span> }
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">list</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">t</span>}
</pre>

<p><em>produces:</em></p>

<pre>#&lt;Thread:0x401b3e84 sleep&gt;
#&lt;Thread:0x401b3f38 run&gt;
#&lt;Thread:0x401b3fb0 sleep&gt;
#&lt;Thread:0x401bdf4c run&gt;</pre>
          

          
          <div class="method-source-code" id="list-source">
            <pre>VALUE
rb_thread_list(void)
{
    VALUE ary = rb_ary_new();
    st_foreach(GET_THREAD()-&gt;vm-&gt;living_threads, thread_list_i, ary);
    return ary;
}</pre>
          </div><!-- list-source -->
          
        </div>

        

        
      </div><!-- list-method -->

    
      <div id="method-c-main" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            main   &rarr; thread
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the main thread.</p>
          

          
          <div class="method-source-code" id="main-source">
            <pre>static VALUE
rb_thread_s_main(VALUE klass)
{
    return rb_thread_main();
}</pre>
          </div><!-- main-source -->
          
        </div>

        

        
      </div><!-- main-method -->

    
      <div id="method-c-pass" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            pass   &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Give the thread scheduler a hint to pass execution to another thread. A
running thread may or may not switch, it depends on OS and processor.</p>
          

          
          <div class="method-source-code" id="pass-source">
            <pre>static VALUE
thread_s_pass(VALUE klass)
{
    rb_thread_schedule();
    return Qnil;
}</pre>
          </div><!-- pass-source -->
          
        </div>

        

        
      </div><!-- pass-method -->

    
      <div id="method-c-start" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            start([args]*) {|args| block }   &rarr; thread
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            fork([args]*) {|args| block }    &rarr; thread
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Basically the same as <code>Thread::new</code>. However, if class
<code>Thread</code> is subclassed, then calling <code>start</code> in that
subclass will not invoke the subclass's <code>initialize</code> method.</p>
          

          
          <div class="method-source-code" id="start-source">
            <pre>static VALUE
thread_start(VALUE klass, VALUE args)
{
    return thread_create_core(rb_thread_alloc(klass), args, 0);
}</pre>
          </div><!-- start-source -->
          
        </div>

        

        
      </div><!-- start-method -->

    
      <div id="method-c-stop" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            stop   &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Stops execution of the current thread, putting it into a "sleep" state, and
schedules execution of another thread.</p>

<pre>a = Thread.new { print &quot;a&quot;; Thread.stop; print &quot;c&quot; }
sleep 0.1 while a.status!='sleep'
print &quot;b&quot;
a.run
a.join</pre>

<p><em>produces:</em></p>

<pre>abc</pre>
          

          
          <div class="method-source-code" id="stop-source">
            <pre>VALUE
rb_thread_stop(void)
{
    if (rb_thread_alone()) {
        rb_raise(rb_eThreadError,
                 &quot;stopping only thread\n\tnote: use sleep to stop forever&quot;);
    }
    rb_thread_sleep_deadly();
    return Qnil;
}</pre>
          </div><!-- stop-source -->
          
        </div>

        

        
      </div><!-- stop-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-5B-5D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            thr[sym]   &rarr; obj or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Attribute Reference---Returns the value of a thread-local variable, using
either a symbol or a string name. If the specified variable does not exist,
returns <code>nil</code>.</p>

<pre class="ruby">[
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[<span class="ruby-string">&quot;name&quot;</span>] = <span class="ruby-string">&quot;A&quot;</span> },
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[:<span class="ruby-identifier">name</span>]  = <span class="ruby-string">&quot;B&quot;</span> },
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[<span class="ruby-string">&quot;name&quot;</span>] = <span class="ruby-string">&quot;C&quot;</span> }
].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">th</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">th</span>.<span class="ruby-identifier">join</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{th.inspect}: #{th[:name]}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p><em>produces:</em></p>

<pre>#&lt;Thread:0x00000002a54220 dead&gt;: A
#&lt;Thread:0x00000002a541a8 dead&gt;: B
#&lt;Thread:0x00000002a54130 dead&gt;: C</pre>
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre>static VALUE
rb_thread_aref(VALUE thread, VALUE id)
{
    return rb_thread_local_aref(thread, rb_to_id(id));
}</pre>
          </div><!-- 5B-5D-source -->
          
        </div>

        

        
      </div><!-- 5B-5D-method -->

    
      <div id="method-i-5B-5D-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            thr[sym] = obj   &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Attribute Assignment---Sets or creates the value of a thread-local
variable, using either a symbol or a string. See also
<code>Thread#[]</code>.</p>
          

          
          <div class="method-source-code" id="5B-5D-3D-source">
            <pre>static VALUE
rb_thread_aset(VALUE self, VALUE id, VALUE val)
{
    return rb_thread_local_aset(self, rb_to_id(id), val);
}</pre>
          </div><!-- 5B-5D-3D-source -->
          
        </div>

        

        
      </div><!-- 5B-5D-3D-method -->

    
      <div id="method-i-abort_on_exception" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            abort_on_exception   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the status of the thread-local "abort on exception" condition for
<em>thr</em>. The default is <code>false</code>. See also
<code>Thread::abort_on_exception=</code>.</p>
          

          
          <div class="method-source-code" id="abort_on_exception-source">
            <pre>static VALUE
rb_thread_abort_exc(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);
    return th-&gt;abort_on_exception ? Qtrue : Qfalse;
}</pre>
          </div><!-- abort_on_exception-source -->
          
        </div>

        

        
      </div><!-- abort_on_exception-method -->

    
      <div id="method-i-abort_on_exception-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            abort_on_exception= boolean   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>When set to <code>true</code>, causes all threads (including the main
program) to abort if an exception is raised in <em>thr</em>. The process
will effectively <code>exit(0)</code>.</p>
          

          
          <div class="method-source-code" id="abort_on_exception-3D-source">
            <pre>static VALUE
rb_thread_abort_exc_set(VALUE thread, VALUE val)
{
    rb_thread_t *th;
    rb_secure(4);

    GetThreadPtr(thread, th);
    th-&gt;abort_on_exception = RTEST(val);
    return val;
}</pre>
          </div><!-- abort_on_exception-3D-source -->
          
        </div>

        

        
      </div><!-- abort_on_exception-3D-method -->

    
      <div id="method-i-add_trace_func" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            add_trace_func(proc)    &rarr; proc
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Adds <em>proc</em> as a handler for tracing. See
<code>Thread#set_trace_func</code> and <code>set_trace_func</code>.</p>
          

          
          <div class="method-source-code" id="add_trace_func-source">
            <pre>static VALUE
thread_add_trace_func_m(VALUE obj, VALUE trace)
{
    rb_thread_t *th;
    GetThreadPtr(obj, th);
    thread_add_trace_func(th, trace);
    return trace;
}</pre>
          </div><!-- add_trace_func-source -->
          
        </div>

        

        
      </div><!-- add_trace_func-method -->

    
      <div id="method-i-alive-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            alive?   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if <em>thr</em> is running or sleeping.</p>

<pre class="ruby"><span class="ruby-identifier">thr</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { }
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">join</span>                <span class="ruby-comment">#=&gt; #&lt;Thread:0x401b3fb0 dead&gt;</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">alive?</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">alive?</span>              <span class="ruby-comment">#=&gt; false</span>
</pre>
          

          
          <div class="method-source-code" id="alive-3F-source">
            <pre>static VALUE
rb_thread_alive_p(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);

    if (rb_threadptr_dead(th))
        return Qfalse;
    return Qtrue;
}</pre>
          </div><!-- alive-3F-source -->
          
        </div>

        

        
      </div><!-- alive-3F-method -->

    
      <div id="method-i-backtrace" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            backtrace    &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the current back trace of the <em>thr</em>.</p>
          

          
          <div class="method-source-code" id="backtrace-source">
            <pre>static VALUE
rb_thread_backtrace_m(VALUE thval)
{
    return rb_thread_backtrace(thval);
}</pre>
          </div><!-- backtrace-source -->
          
        </div>

        

        
      </div><!-- backtrace-method -->

    
      <div id="method-i-exit" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            exit        &rarr; thr or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            kill        &rarr; thr or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            terminate   &rarr; thr or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Terminates <em>thr</em> and schedules another thread to be run. If this
thread is already marked to be killed, <code>exit</code> returns the
<code>Thread</code>. If this is the main thread, or the last thread, exits
the process.</p>
          

          
          <div class="method-source-code" id="exit-source">
            <pre>VALUE
rb_thread_kill(VALUE thread)
{
    rb_thread_t *th;

    GetThreadPtr(thread, th);

    if (th != GET_THREAD() &amp;&amp; th-&gt;safe_level &lt; 4) {
        rb_secure(4);
    }
    if (th-&gt;status == THREAD_TO_KILL || th-&gt;status == THREAD_KILLED) {
        return thread;
    }
    if (th == th-&gt;vm-&gt;main_thread) {
        rb_exit(EXIT_SUCCESS);
    }

    thread_debug(&quot;rb_thread_kill: %p (%p)\n&quot;, (void *)th, (void *)th-&gt;thread_id);

    rb_threadptr_interrupt(th);
    th-&gt;thrown_errinfo = eKillSignal;
    th-&gt;status = THREAD_TO_KILL;

    return thread;
}</pre>
          </div><!-- exit-source -->
          
        </div>

        

        
      </div><!-- exit-method -->

    
      <div id="method-i-group" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            group   &rarr; thgrp or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the <code>ThreadGroup</code> which contains <em>thr</em>, or nil if
the thread is not a member of any group.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">main</span>.<span class="ruby-identifier">group</span>   <span class="ruby-comment">#=&gt; #&lt;ThreadGroup:0x4029d914&gt;</span>
</pre>
          

          
          <div class="method-source-code" id="group-source">
            <pre>VALUE
rb_thread_group(VALUE thread)
{
    rb_thread_t *th;
    VALUE group;
    GetThreadPtr(thread, th);
    group = th-&gt;thgroup;

    if (!group) {
        group = Qnil;
    }
    return group;
}</pre>
          </div><!-- group-source -->
          
        </div>

        

        
      </div><!-- group-method -->

    
      <div id="method-i-inspect" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            inspect   &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Dump the name, id, and status of <em>thr</em> to a string.</p>
          

          
          <div class="method-source-code" id="inspect-source">
            <pre>static VALUE
rb_thread_inspect(VALUE thread)
{
    const char *cname = rb_obj_classname(thread);
    rb_thread_t *th;
    const char *status;
    VALUE str;

    GetThreadPtr(thread, th);
    status = thread_status_name(th-&gt;status);
    str = rb_sprintf(&quot;#&lt;%s:%p %s&gt;&quot;, cname, (void *)thread, status);
    OBJ_INFECT(str, thread);

    return str;
}</pre>
          </div><!-- inspect-source -->
          
        </div>

        

        
      </div><!-- inspect-method -->

    
      <div id="method-i-join" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            join          &rarr; thr
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            join(limit)   &rarr; thr
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>The calling thread will suspend execution and run <em>thr</em>. Does not
return until <em>thr</em> exits or until <em>limit</em> seconds have
passed. If the time limit expires, <code>nil</code> will be returned,
otherwise <em>thr</em> is returned.</p>

<p>Any threads not joined will be killed when the main program exits.  If
<em>thr</em> had previously raised an exception and the
<code>abort_on_exception</code> and <code>$DEBUG</code> flags are not set
(so the exception has not yet been processed) it will be processed at this
time.</p>

<pre>a = Thread.new { print &quot;a&quot;; sleep(10); print &quot;b&quot;; print &quot;c&quot; }
x = Thread.new { print &quot;x&quot;; Thread.pass; print &quot;y&quot;; print &quot;z&quot; }
x.join # Let x thread finish, a will be killed on exit.</pre>

<p><em>produces:</em></p>

<pre>axyz</pre>

<p>The following example illustrates the <em>limit</em> parameter.</p>

<pre>y = Thread.new { 4.times { sleep 0.1; puts 'tick... ' }}
puts &quot;Waiting&quot; until y.join(0.15)</pre>

<p><em>produces:</em></p>

<pre>tick...
Waiting
tick...
Waitingtick...

tick...</pre>
          

          
          <div class="method-source-code" id="join-source">
            <pre>static VALUE
thread_join_m(int argc, VALUE *argv, VALUE self)
{
    rb_thread_t *target_th;
    double delay = DELAY_INFTY;
    VALUE limit;

    GetThreadPtr(self, target_th);

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;limit);
    if (!NIL_P(limit)) {
        delay = rb_num2dbl(limit);
    }

    return thread_join(target_th, delay);
}</pre>
          </div><!-- join-source -->
          
        </div>

        

        
      </div><!-- join-method -->

    
      <div id="method-i-key-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            key?(sym)   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if the given string (or symbol) exists as a
thread-local variable.</p>

<pre class="ruby"><span class="ruby-identifier">me</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>
<span class="ruby-identifier">me</span>[:<span class="ruby-identifier">oliver</span>] = <span class="ruby-string">&quot;a&quot;</span>
<span class="ruby-identifier">me</span>.<span class="ruby-identifier">key?</span>(:<span class="ruby-identifier">oliver</span>)    <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">me</span>.<span class="ruby-identifier">key?</span>(:<span class="ruby-identifier">stanley</span>)   <span class="ruby-comment">#=&gt; false</span>
</pre>
          

          
          <div class="method-source-code" id="key-3F-source">
            <pre>static VALUE
rb_thread_key_p(VALUE self, VALUE key)
{
    rb_thread_t *th;
    ID id = rb_to_id(key);

    GetThreadPtr(self, th);

    if (!th-&gt;local_storage) {
        return Qfalse;
    }
    if (st_lookup(th-&gt;local_storage, id, 0)) {
        return Qtrue;
    }
    return Qfalse;
}</pre>
          </div><!-- key-3F-source -->
          
        </div>

        

        
      </div><!-- key-3F-method -->

    
      <div id="method-i-keys" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            keys   &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an an array of the names of the thread-local variables (as
Symbols).</p>

<pre class="ruby"><span class="ruby-identifier">thr</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[:<span class="ruby-identifier">cat</span>] = <span class="ruby-string">'meow'</span>
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>[<span class="ruby-string">&quot;dog&quot;</span>] = <span class="ruby-string">'woof'</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">join</span>   <span class="ruby-comment">#=&gt; #&lt;Thread:0x401b3f10 dead&gt;</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">keys</span>   <span class="ruby-comment">#=&gt; [:dog, :cat]</span>
</pre>
          

          
          <div class="method-source-code" id="keys-source">
            <pre>static VALUE
rb_thread_keys(VALUE self)
{
    rb_thread_t *th;
    VALUE ary = rb_ary_new();
    GetThreadPtr(self, th);

    if (th-&gt;local_storage) {
        st_foreach(th-&gt;local_storage, thread_keys_i, ary);
    }
    return ary;
}</pre>
          </div><!-- keys-source -->
          
        </div>

        

        
      </div><!-- keys-method -->

    
      <div id="method-i-kill" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            exit        &rarr; thr or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            kill        &rarr; thr or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            terminate   &rarr; thr or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Terminates <em>thr</em> and schedules another thread to be run. If this
thread is already marked to be killed, <code>exit</code> returns the
<code>Thread</code>. If this is the main thread, or the last thread, exits
the process.</p>
          

          
          <div class="method-source-code" id="kill-source">
            <pre>VALUE
rb_thread_kill(VALUE thread)
{
    rb_thread_t *th;

    GetThreadPtr(thread, th);

    if (th != GET_THREAD() &amp;&amp; th-&gt;safe_level &lt; 4) {
        rb_secure(4);
    }
    if (th-&gt;status == THREAD_TO_KILL || th-&gt;status == THREAD_KILLED) {
        return thread;
    }
    if (th == th-&gt;vm-&gt;main_thread) {
        rb_exit(EXIT_SUCCESS);
    }

    thread_debug(&quot;rb_thread_kill: %p (%p)\n&quot;, (void *)th, (void *)th-&gt;thread_id);

    rb_threadptr_interrupt(th);
    th-&gt;thrown_errinfo = eKillSignal;
    th-&gt;status = THREAD_TO_KILL;

    return thread;
}</pre>
          </div><!-- kill-source -->
          
        </div>

        

        
      </div><!-- kill-method -->

    
      <div id="method-i-priority" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            priority   &rarr; integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the priority of <em>thr</em>. Default is inherited from the current
thread which creating the new thread, or zero for the initial main thread;
higher-priority thread will run more frequently than lower-priority threads
(but lower-priority threads can also run).</p>

<p>This is just hint for Ruby thread scheduler.  It may be ignored on some
platform.</p>

<pre class="ruby"><span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">priority</span>   <span class="ruby-comment">#=&gt; 0</span>
</pre>
          

          
          <div class="method-source-code" id="priority-source">
            <pre>static VALUE
rb_thread_priority(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);
    return INT2NUM(th-&gt;priority);
}</pre>
          </div><!-- priority-source -->
          
        </div>

        

        
      </div><!-- priority-method -->

    
      <div id="method-i-priority-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            priority= integer   &rarr; thr
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets the priority of <em>thr</em> to <em>integer</em>. Higher-priority
threads will run more frequently than lower-priority threads (but
lower-priority threads can also run).</p>

<p>This is just hint for Ruby thread scheduler.  It may be ignored on some
platform.</p>

<pre class="ruby"><span class="ruby-identifier">count1</span> = <span class="ruby-identifier">count2</span> = <span class="ruby-value">0</span>
<span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">loop</span> { <span class="ruby-identifier">count1</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> }
    <span class="ruby-keyword">end</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">priority</span> = <span class="ruby-value">-1</span>

<span class="ruby-identifier">b</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">loop</span> { <span class="ruby-identifier">count2</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> }
    <span class="ruby-keyword">end</span>
<span class="ruby-identifier">b</span>.<span class="ruby-identifier">priority</span> = <span class="ruby-value">-2</span>
<span class="ruby-identifier">sleep</span> <span class="ruby-value">1</span>   <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">count1</span>    <span class="ruby-comment">#=&gt; 622504</span>
<span class="ruby-identifier">count2</span>    <span class="ruby-comment">#=&gt; 5832</span>
</pre>
          

          
          <div class="method-source-code" id="priority-3D-source">
            <pre>static VALUE
rb_thread_priority_set(VALUE thread, VALUE prio)
{
    rb_thread_t *th;
    int priority;
    GetThreadPtr(thread, th);

    rb_secure(4);

#if USE_NATIVE_THREAD_PRIORITY
    th-&gt;priority = NUM2INT(prio);
    native_thread_apply_priority(th);
#else
    priority = NUM2INT(prio);
    if (priority &gt; RUBY_THREAD_PRIORITY_MAX) {
        priority = RUBY_THREAD_PRIORITY_MAX;
    }
    else if (priority &lt; RUBY_THREAD_PRIORITY_MIN) {
        priority = RUBY_THREAD_PRIORITY_MIN;
    }
    th-&gt;priority = priority;
#endif
    return INT2NUM(th-&gt;priority);
}</pre>
          </div><!-- priority-3D-source -->
          
        </div>

        

        
      </div><!-- priority-3D-method -->

    
      <div id="method-i-raise" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            raise
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            raise(string)
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            raise(exception [, string [, array]])
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Raises an exception (see <code>Kernel::raise</code>) from <em>thr</em>. The
caller does not have to be <em>thr</em>.</p>

<pre>Thread.abort_on_exception = true
a = Thread.new { sleep(200) }
a.raise(&quot;Gotcha&quot;)</pre>

<p><em>produces:</em></p>

<pre>prog.rb:3: Gotcha (RuntimeError)
 from prog.rb:2:in `initialize'
 from prog.rb:2:in `new'
 from prog.rb:2</pre>
          

          
          <div class="method-source-code" id="raise-source">
            <pre>static VALUE
thread_raise_m(int argc, VALUE *argv, VALUE self)
{
    rb_thread_t *th;
    GetThreadPtr(self, th);
    rb_threadptr_raise(th, argc, argv);
    return Qnil;
}</pre>
          </div><!-- raise-source -->
          
        </div>

        

        
      </div><!-- raise-method -->

    
      <div id="method-i-run" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            run   &rarr; thr
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Wakes up <em>thr</em>, making it eligible for scheduling.</p>

<pre>a = Thread.new { puts &quot;a&quot;; Thread.stop; puts &quot;c&quot; }
sleep 0.1 while a.status!='sleep'
puts &quot;Got here&quot;
a.run
a.join</pre>

<p><em>produces:</em></p>

<pre>a
Got here
c</pre>
          

          
          <div class="method-source-code" id="run-source">
            <pre>VALUE
rb_thread_run(VALUE thread)
{
    rb_thread_wakeup(thread);
    rb_thread_schedule();
    return thread;
}</pre>
          </div><!-- run-source -->
          
        </div>

        

        
      </div><!-- run-method -->

    
      <div id="method-i-safe_level" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            safe_level   &rarr; integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the safe level in effect for <em>thr</em>. Setting thread-local
safe levels can help when implementing sandboxes which run insecure code.</p>

<pre class="ruby"><span class="ruby-identifier">thr</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">$SAFE</span> = <span class="ruby-value">3</span>; <span class="ruby-identifier">sleep</span> }
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">safe_level</span>   <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">thr</span>.<span class="ruby-identifier">safe_level</span>              <span class="ruby-comment">#=&gt; 3</span>
</pre>
          

          
          <div class="method-source-code" id="safe_level-source">
            <pre>static VALUE
rb_thread_safe_level(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);

    return INT2NUM(th-&gt;safe_level);
}</pre>
          </div><!-- safe_level-source -->
          
        </div>

        

        
      </div><!-- safe_level-method -->

    
      <div id="method-i-set_trace_func" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            set_trace_func(proc)    &rarr; proc
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            set_trace_func(nil)     &rarr; nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Establishes <em>proc</em> on <em>thr</em> as the handler for tracing, or
disables tracing if the parameter is <code>nil</code>. See
<code>set_trace_func</code>.</p>
          

          
          <div class="method-source-code" id="set_trace_func-source">
            <pre>static VALUE
thread_set_trace_func_m(VALUE obj, VALUE trace)
{
    rb_thread_t *th;
    GetThreadPtr(obj, th);
    rb_threadptr_remove_event_hook(th, call_trace_func);

    if (NIL_P(trace)) {
        th-&gt;tracing = EVENT_RUNNING_NOTHING;
        return Qnil;
    }
    thread_add_trace_func(th, trace);
    return trace;
}</pre>
          </div><!-- set_trace_func-source -->
          
        </div>

        

        
      </div><!-- set_trace_func-method -->

    
      <div id="method-i-status" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            status   &rarr; string, false or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the status of <em>thr</em>: "<code>sleep</code>" if <em>thr</em> is
sleeping or waiting on I/O, "<code>run</code>" if <em>thr</em> is
executing, "<code>aborting</code>" if <em>thr</em> is aborting,
<code>false</code> if <em>thr</em> terminated normally, and
<code>nil</code> if <em>thr</em> terminated with an exception.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">raise</span>(<span class="ruby-string">&quot;die now&quot;</span>) }
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">stop</span> }
<span class="ruby-identifier">c</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">exit</span> }
<span class="ruby-identifier">d</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">sleep</span> }
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">kill</span>                  <span class="ruby-comment">#=&gt; #&lt;Thread:0x401b3678 aborting&gt;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">status</span>                <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">b</span>.<span class="ruby-identifier">status</span>                <span class="ruby-comment">#=&gt; &quot;sleep&quot;</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">status</span>                <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">status</span>                <span class="ruby-comment">#=&gt; &quot;aborting&quot;</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>.<span class="ruby-identifier">status</span>   <span class="ruby-comment">#=&gt; &quot;run&quot;</span>
</pre>
          

          
          <div class="method-source-code" id="status-source">
            <pre>static VALUE
rb_thread_status(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);

    if (rb_threadptr_dead(th)) {
        if (!NIL_P(th-&gt;errinfo) &amp;&amp; !FIXNUM_P(th-&gt;errinfo)
            /* TODO */ ) {
            return Qnil;
        }
        return Qfalse;
    }
    return rb_str_new2(thread_status_name(th-&gt;status));
}</pre>
          </div><!-- status-source -->
          
        </div>

        

        
      </div><!-- status-method -->

    
      <div id="method-i-stop-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            stop?   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if <em>thr</em> is dead or sleeping.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">stop</span> }
<span class="ruby-identifier">b</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">current</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">stop?</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">b</span>.<span class="ruby-identifier">stop?</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>
          

          
          <div class="method-source-code" id="stop-3F-source">
            <pre>static VALUE
rb_thread_stop_p(VALUE thread)
{
    rb_thread_t *th;
    GetThreadPtr(thread, th);

    if (rb_threadptr_dead(th))
        return Qtrue;
    if (th-&gt;status == THREAD_STOPPED || th-&gt;status == THREAD_STOPPED_FOREVER)
        return Qtrue;
    return Qfalse;
}</pre>
          </div><!-- stop-3F-source -->
          
        </div>

        

        
      </div><!-- stop-3F-method -->

    
      <div id="method-i-terminate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            exit        &rarr; thr or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            kill        &rarr; thr or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            terminate   &rarr; thr or nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Terminates <em>thr</em> and schedules another thread to be run. If this
thread is already marked to be killed, <code>exit</code> returns the
<code>Thread</code>. If this is the main thread, or the last thread, exits
the process.</p>
          

          
          <div class="method-source-code" id="terminate-source">
            <pre>VALUE
rb_thread_kill(VALUE thread)
{
    rb_thread_t *th;

    GetThreadPtr(thread, th);

    if (th != GET_THREAD() &amp;&amp; th-&gt;safe_level &lt; 4) {
        rb_secure(4);
    }
    if (th-&gt;status == THREAD_TO_KILL || th-&gt;status == THREAD_KILLED) {
        return thread;
    }
    if (th == th-&gt;vm-&gt;main_thread) {
        rb_exit(EXIT_SUCCESS);
    }

    thread_debug(&quot;rb_thread_kill: %p (%p)\n&quot;, (void *)th, (void *)th-&gt;thread_id);

    rb_threadptr_interrupt(th);
    th-&gt;thrown_errinfo = eKillSignal;
    th-&gt;status = THREAD_TO_KILL;

    return thread;
}</pre>
          </div><!-- terminate-source -->
          
        </div>

        

        
      </div><!-- terminate-method -->

    
      <div id="method-i-value" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            value   &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Waits for <em>thr</em> to complete (via <code>Thread#join</code>) and
returns its value.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-value">2</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span> }
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">value</span>   <span class="ruby-comment">#=&gt; 4</span>
</pre>
          

          
          <div class="method-source-code" id="value-source">
            <pre>static VALUE
thread_value(VALUE self)
{
    rb_thread_t *th;
    GetThreadPtr(self, th);
    thread_join(th, DELAY_INFTY);
    return th-&gt;value;
}</pre>
          </div><!-- value-source -->
          
        </div>

        

        
      </div><!-- value-method -->

    
      <div id="method-i-wakeup" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            wakeup   &rarr; thr
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Marks <em>thr</em> as eligible for scheduling (it may still remain blocked
on I/O, however). Does not invoke the scheduler (see
<code>Thread#run</code>).</p>

<pre>c = Thread.new { Thread.stop; puts &quot;hey!&quot; }
sleep 0.1 while c.status!='sleep'
c.wakeup
c.join</pre>

<p><em>produces:</em></p>

<pre>hey!</pre>
          

          
          <div class="method-source-code" id="wakeup-source">
            <pre>VALUE
rb_thread_wakeup(VALUE thread)
{
    if (!RTEST(rb_thread_wakeup_alive(thread))) {
        rb_raise(rb_eThreadError, &quot;killed thread&quot;);
    }
    return thread;
}</pre>
          </div><!-- wakeup-source -->
          
        </div>

        

        
      </div><!-- wakeup-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

