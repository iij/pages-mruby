<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=US-ASCII" http-equiv="Content-Type">

<title>module Enumerable - RDoc Documentation</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body id="top" class="module">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>enum.c
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    
    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li style="background: #cfc;" ><a href="#method-i-all-3F">#all?</a>
    
    <li style="background: #cfc;" ><a href="#method-i-any-3F">#any?</a>
    
    <li  ><a href="#method-i-chunk">#chunk</a>
    
    <li style="background: #cfc;" ><a href="#method-i-collect">#collect</a>
    
    <li  ><a href="#method-i-collect_concat">#collect_concat</a>
    
    <li  ><a href="#method-i-count">#count</a>
    
    <li  ><a href="#method-i-cycle">#cycle</a>
    
    <li style="background: #cfc;" ><a href="#method-i-detect">#detect</a>
    
    <li  ><a href="#method-i-drop">#drop</a>
    
    <li  ><a href="#method-i-drop_while">#drop_while</a>
    
    <li  ><a href="#method-i-each_cons">#each_cons</a>
    
    <li  ><a href="#method-i-each_entry">#each_entry</a>
    
    <li  ><a href="#method-i-each_slice">#each_slice</a>
    
    <li style="background: #cfc;" ><a href="#method-i-each_with_index">#each_with_index</a>
    
    <li  ><a href="#method-i-each_with_object">#each_with_object</a>
    
    <li style="background: #cfc;" ><a href="#method-i-entries">#entries</a>
    
    <li style="background: #cfc;" ><a href="#method-i-find">#find</a>
    
    <li style="background: #cfc;" ><a href="#method-i-find_all">#find_all</a>
    
    <li  ><a href="#method-i-find_index">#find_index</a>
    
    <li  ><a href="#method-i-first">#first</a>
    
    <li  ><a href="#method-i-flat_map">#flat_map</a>
    
    <li style="background: #cfc;" ><a href="#method-i-grep">#grep</a>
    
    <li  ><a href="#method-i-group_by">#group_by</a>
    
    <li style="background: #cfc;" ><a href="#method-i-include-3F">#include?</a>
    
    <li style="background: #cfc;" ><a href="#method-i-inject">#inject</a>
    
    <li style="background: #cfc;" ><a href="#method-i-map">#map</a>
    
    <li style="background: #cfc;" ><a href="#method-i-max">#max</a>
    
    <li  ><a href="#method-i-max_by">#max_by</a>
    
    <li style="background: #cfc;" ><a href="#method-i-member-3F">#member?</a>
    
    <li style="background: #cfc;" ><a href="#method-i-min">#min</a>
    
    <li  ><a href="#method-i-min_by">#min_by</a>
    
    <li  ><a href="#method-i-minmax">#minmax</a>
    
    <li  ><a href="#method-i-minmax_by">#minmax_by</a>
    
    <li  ><a href="#method-i-none-3F">#none?</a>
    
    <li  ><a href="#method-i-one-3F">#one?</a>
    
    <li style="background: #cfc;" ><a href="#method-i-partition">#partition</a>
    
    <li  ><a href="#method-i-reduce">#reduce</a>
    
    <li style="background: #cfc;" ><a href="#method-i-reject">#reject</a>
    
    <li  ><a href="#method-i-reverse_each">#reverse_each</a>
    
    <li style="background: #cfc;" ><a href="#method-i-select">#select</a>
    
    <li  ><a href="#method-i-slice_before">#slice_before</a>
    
    <li style="background: #cfc;" ><a href="#method-i-sort">#sort</a>
    
    <li  ><a href="#method-i-sort_by">#sort_by</a>
    
    <li  ><a href="#method-i-take">#take</a>
    
    <li  ><a href="#method-i-take_while">#take_while</a>
    
    <li style="background: #cfc;" ><a href="#method-i-to_a">#to_a</a>
    
    <li  ><a href="#method-i-zip">#zip</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="./ext/syslog/syslog_txt.html">syslog</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li style="background: #ffc;"><a href="./Digest.html">Digest</a>
  
    <li style="background: #ffc;"><a href="./Digest/Base.html">Digest::Base</a>
  
    <li ><a href="./Digest/Class.html">Digest::Class</a>
  
    <li style="background: #ffc;"><a href="./Digest/HMAC.html">Digest::HMAC</a>
  
    <li ><a href="./Digest/Instance.html">Digest::Instance</a>
  
    <li style="background: #ffc;"><a href="./Digest/SHA2.html">Digest::SHA2</a>
  
    <li ><a href="./Encoding.html">Encoding</a>
  
    <li ><a href="./Encoding/CompatibilityError.html">Encoding::CompatibilityError</a>
  
    <li ><a href="./Encoding/Converter.html">Encoding::Converter</a>
  
    <li ><a href="./Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a>
  
    <li ><a href="./Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
  
    <li ><a href="./Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a>
  
    <li style="background: #ffc;"><a href="./Process.html">Process</a>
  
    <li ><a href="./Process/GID.html">Process::GID</a>
  
    <li ><a href="./Process/Status.html">Process::Status</a>
  
    <li ><a href="./Process/Sys.html">Process::Sys</a>
  
    <li ><a href="./Process/UID.html">Process::UID</a>
  
    <li ><a href="./Socket.html">Socket</a>
  
    <li ><a href="./Socket/AncillaryData.html">Socket::AncillaryData</a>
  
    <li ><a href="./Socket/Option.html">Socket::Option</a>
  
    <li ><a href="./Socket/UDPSource.html">Socket::UDPSource</a>
  
    <li ><a href="./Enumerator.html">Enumerator</a>
  
    <li ><a href="./Enumerator/Generator.html">Enumerator::Generator</a>
  
    <li ><a href="./Enumerator/Yielder.html">Enumerator::Yielder</a>
  
    <li style="background: #ffc;"><a href="./File.html">File</a>
  
    <li ><a href="./File/Constants.html">File::Constants</a>
  
    <li ><a href="./File/Stat.html">File::Stat</a>
  
    <li style="background: #ffc;"><a href="./IO.html">IO</a>
  
    <li ><a href="./IO/WaitReadable.html">IO::WaitReadable</a>
  
    <li ><a href="./IO/WaitWritable.html">IO::WaitWritable</a>
  
    <li ><a href="./RubyVM.html">RubyVM</a>
  
    <li ><a href="./RubyVM/Env.html">RubyVM::Env</a>
  
    <li ><a href="./RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a>
  
    <li style="background: #ffc;"><a href="./GC.html">GC</a>
  
    <li ><a href="./GC/Profiler.html">GC::Profiler</a>
  
    <li style="background: #ffc;"><a href="./Math.html">Math</a>
  
    <li ><a href="./Math/DomainError.html">Math::DomainError</a>
  
    <li style="background: #ffc;"><a href="./Syslog.html">Syslog</a>
  
    <li ><a href="./Syslog/Constants.html">Syslog::Constants</a>
  
    <li ><a href="./ARGF.html">ARGF</a>
  
    <li ><a href="./Addrinfo.html">Addrinfo</a>
  
    <li style="background: #ffc;"><a href="./ArgumentError.html">ArgumentError</a>
  
    <li style="background: #ffc;"><a href="./Array.html">Array</a>
  
    <li style="background: #ffc;"><a href="./BasicObject.html">BasicObject</a>
  
    <li style="background: #ffc;"><a href="./BasicSocket.html">BasicSocket</a>
  
    <li ><a href="./Bignum.html">Bignum</a>
  
    <li ><a href="./Binding.html">Binding</a>
  
    <li style="background: #ffc;"><a href="./Class.html">Class</a>
  
    <li style="background: #ffc;"><a href="./Comparable.html">Comparable</a>
  
    <li ><a href="./Complex.html">Complex</a>
  
    <li ><a href="./Continuation.html">Continuation</a>
  
    <li ><a href="./Data.html">Data</a>
  
    <li style="background: #ffc;"><a href="./Dir.html">Dir</a>
  
    <li style="background: #ffc;"><a href="./ENV.html">ENV</a>
  
    <li style="background: #ffc;"><a href="./EOFError.html">EOFError</a>
  
    <li style="background: #ffc;"><a href="./EncodingError.html">EncodingError</a>
  
    <li style="background: #ffc;"><a href="./Enumerable.html">Enumerable</a>
  
    <li style="background: #ffc;"><a href="./Errno.html">Errno</a>
  
    <li style="background: #ffc;"><a href="./Exception.html">Exception</a>
  
    <li style="background: #ffc;"><a href="./FalseClass.html">FalseClass</a>
  
    <li ><a href="./Fiber.html">Fiber</a>
  
    <li ><a href="./FiberError.html">FiberError</a>
  
    <li ><a href="./FileTest.html">FileTest</a>
  
    <li style="background: #ffc;"><a href="./Fixnum.html">Fixnum</a>
  
    <li style="background: #ffc;"><a href="./Float.html">Float</a>
  
    <li style="background: #ffc;"><a href="./FloatDomainError.html">FloatDomainError</a>
  
    <li style="background: #ffc;"><a href="./Hash.html">Hash</a>
  
    <li style="background: #ffc;"><a href="./IOError.html">IOError</a>
  
    <li style="background: #ffc;"><a href="./IPAddr.html">IPAddr</a>
  
    <li style="background: #ffc;"><a href="./IPSocket.html">IPSocket</a>
  
    <li style="background: #ffc;"><a href="./IndexError.html">IndexError</a>
  
    <li style="background: #ffc;"><a href="./Integer.html">Integer</a>
  
    <li ><a href="./Interrupt.html">Interrupt</a>
  
    <li style="background: #ffc;"><a href="./Kernel.html">Kernel</a>
  
    <li style="background: #ffc;"><a href="./KeyError.html">KeyError</a>
  
    <li ><a href="./LoadError.html">LoadError</a>
  
    <li style="background: #ffc;"><a href="./LocalJumpError.html">LocalJumpError</a>
  
    <li ><a href="./Marshal.html">Marshal</a>
  
    <li style="background: #ffc;"><a href="./MatchData.html">MatchData</a>
  
    <li ><a href="./Method.html">Method</a>
  
    <li style="background: #ffc;"><a href="./Module.html">Module</a>
  
    <li ><a href="./Mutex.html">Mutex</a>
  
    <li style="background: #ffc;"><a href="./NameError.html">NameError</a>
  
    <li style="background: #ffc;"><a href="./NilClass.html">NilClass</a>
  
    <li ><a href="./NoMemoryError.html">NoMemoryError</a>
  
    <li style="background: #ffc;"><a href="./NoMethodError.html">NoMethodError</a>
  
    <li style="background: #ffc;"><a href="./NotImplementedError.html">NotImplementedError</a>
  
    <li style="background: #ffc;"><a href="./Numeric.html">Numeric</a>
  
    <li style="background: #ffc;"><a href="./Object.html">Object</a>
  
    <li ><a href="./ObjectSpace.html">ObjectSpace</a>
  
    <li style="background: #ffc;"><a href="./Proc.html">Proc</a>
  
    <li ><a href="./Random.html">Random</a>
  
    <li style="background: #ffc;"><a href="./Range.html">Range</a>
  
    <li style="background: #ffc;"><a href="./RangeError.html">RangeError</a>
  
    <li ><a href="./Rational.html">Rational</a>
  
    <li style="background: #ffc;"><a href="./Regexp.html">Regexp</a>
  
    <li style="background: #ffc;"><a href="./RegexpError.html">RegexpError</a>
  
    <li ><a href="./Ripper.html">Ripper</a>
  
    <li style="background: #ffc;"><a href="./RuntimeError.html">RuntimeError</a>
  
    <li ><a href="./SOCKSSocket.html">SOCKSSocket</a>
  
    <li style="background: #ffc;"><a href="./ScriptError.html">ScriptError</a>
  
    <li ><a href="./SecurityError.html">SecurityError</a>
  
    <li ><a href="./Signal.html">Signal</a>
  
    <li ><a href="./SignalException.html">SignalException</a>
  
    <li ><a href="./SocketError.html">SocketError</a>
  
    <li style="background: #ffc;"><a href="./StandardError.html">StandardError</a>
  
    <li ><a href="./StopIteration.html">StopIteration</a>
  
    <li style="background: #ffc;"><a href="./String.html">String</a>
  
    <li style="background: #ffc;"><a href="./Struct.html">Struct</a>
  
    <li style="background: #ffc;"><a href="./Symbol.html">Symbol</a>
  
    <li style="background: #ffc;"><a href="./SyntaxError.html">SyntaxError</a>
  
    <li style="background: #ffc;"><a href="./SystemCallError.html">SystemCallError</a>
  
    <li ><a href="./SystemExit.html">SystemExit</a>
  
    <li ><a href="./SystemStackError.html">SystemStackError</a>
  
    <li ><a href="./TCPServer.html">TCPServer</a>
  
    <li style="background: #ffc;"><a href="./TCPSocket.html">TCPSocket</a>
  
    <li ><a href="./Thread.html">Thread</a>
  
    <li ><a href="./ThreadError.html">ThreadError</a>
  
    <li ><a href="./ThreadGroup.html">ThreadGroup</a>
  
    <li style="background: #ffc;"><a href="./Time.html">Time</a>
  
    <li style="background: #ffc;"><a href="./TrueClass.html">TrueClass</a>
  
    <li style="background: #ffc;"><a href="./TypeError.html">TypeError</a>
  
    <li style="background: #ffc;"><a href="./UDPSocket.html">UDPSocket</a>
  
    <li ><a href="./UNIXServer.html">UNIXServer</a>
  
    <li style="background: #ffc;"><a href="./UNIXSocket.html">UNIXSocket</a>
  
    <li ><a href="./UnboundMethod.html">UnboundMethod</a>
  
    <li ><a href="./ZeroDivisionError.html">ZeroDivisionError</a>
  
    <li ><a href="./fatal.html">fatal</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="module" style="background: #ffc;" >module Enumerable</h1>

  <div style="background: #ddd;">
    
            <span style="background: #cfc;" >all?</span>
    
            <span style="background: #cfc;" >any?</span>
    
            <span  >chunk</span>
    
            <span style="background: #cfc;" >collect</span>
    
            <span  >collect_concat</span>
    
            <span  >count</span>
    
            <span  >cycle</span>
    
            <span style="background: #cfc;" >detect</span>
    
            <span  >drop</span>
    
            <span  >drop_while</span>
    
            <span  >each_cons</span>
    
            <span  >each_entry</span>
    
            <span  >each_slice</span>
    
            <span style="background: #cfc;" >each_with_index</span>
    
            <span  >each_with_object</span>
    
            <span style="background: #cfc;" >entries</span>
    
            <span style="background: #cfc;" >find</span>
    
            <span style="background: #cfc;" >find_all</span>
    
            <span  >find_index</span>
    
            <span  >first</span>
    
            <span  >flat_map</span>
    
            <span style="background: #cfc;" >grep</span>
    
            <span  >group_by</span>
    
            <span style="background: #cfc;" >include?</span>
    
            <span style="background: #cfc;" >inject</span>
    
            <span style="background: #cfc;" >map</span>
    
            <span style="background: #cfc;" >max</span>
    
            <span  >max_by</span>
    
            <span style="background: #cfc;" >member?</span>
    
            <span style="background: #cfc;" >min</span>
    
            <span  >min_by</span>
    
            <span  >minmax</span>
    
            <span  >minmax_by</span>
    
            <span  >none?</span>
    
            <span  >one?</span>
    
            <span style="background: #cfc;" >partition</span>
    
            <span  >reduce</span>
    
            <span style="background: #cfc;" >reject</span>
    
            <span  >reverse_each</span>
    
            <span style="background: #cfc;" >select</span>
    
            <span  >slice_before</span>
    
            <span style="background: #cfc;" >sort</span>
    
            <span  >sort_by</span>
    
            <span  >take</span>
    
            <span  >take_while</span>
    
            <span style="background: #cfc;" >to_a</span>
    
            <span  >zip</span>
    
  </div>

  <div id="description" class="description">
    
<p>The <code>Enumerable</code> mixin provides collection classes with several
traversal and searching methods, and with the ability to sort. The class
must provide a method <code>each</code>, which yields successive members of
the collection. If <code>Enumerable#max</code>, <code>#min</code>, or
<code>#sort</code> is used, the objects in the collection must also
implement a meaningful <code>&lt;=&gt;</code> operator, as these methods
rely on an ordering between members of the collection.</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    <!-- Methods -->
    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-all-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            all? [{|obj| block } ]   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block never returns <code>false</code> or
<code>nil</code>. If the block is not given, Ruby adds an implicit block of
<code>{|obj| obj}</code> (that is <code>all?</code> will return
<code>true</code> only if none of the collection members are
<code>false</code> or <code>nil</code>.)</p>

<pre class="ruby"><span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">all?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">3</span>}   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">all?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">4</span>}   <span class="ruby-comment">#=&gt; false</span>
[ <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-value">99</span> ].<span class="ruby-identifier">all?</span>                            <span class="ruby-comment">#=&gt; false</span>
</pre>
          

          
          <div class="method-source-code" id="all-3F-source">
            <pre>static VALUE
enum_all(VALUE obj)
{
    VALUE result = Qtrue;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(all), (VALUE)&amp;result);
    return result;
}</pre>
          </div><!-- all-3F-source -->
          
        </div>

        

        
      </div><!-- all-3F-method -->

    
      <div id="method-i-any-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            any? [{|obj| block } ]   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block ever returns a value other than
<code>false</code> or <code>nil</code>. If the block is not given, Ruby
adds an implicit block of <code>{|obj| obj}</code> (that is
<code>any?</code> will return <code>true</code> if at least one of the
collection members is not <code>false</code> or <code>nil</code>.</p>

<pre class="ruby"><span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">3</span>}   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">4</span>}   <span class="ruby-comment">#=&gt; true</span>
[ <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-value">99</span> ].<span class="ruby-identifier">any?</span>                            <span class="ruby-comment">#=&gt; true</span>
</pre>
          

          
          <div class="method-source-code" id="any-3F-source">
            <pre>static VALUE
enum_any(VALUE obj)
{
    VALUE result = Qfalse;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(any), (VALUE)&amp;result);
    return result;
}</pre>
          </div><!-- any-3F-source -->
          
        </div>

        

        
      </div><!-- any-3F-method -->

    
      <div id="method-i-chunk" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            chunk {|elt| ... }                       &rarr; an_enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            chunk(initial_state) {|elt, state| ... } &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates an enumerator for each chunked elements. The consecutive elements
which have same block value are chunked.</p>

<p>The result enumerator yields the block value and an array of chunked
elements. So "each" method can be called as follows.</p>

<pre class="ruby"><span class="ruby-identifier">enum</span>.<span class="ruby-identifier">chunk</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">elt</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span> }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">ary</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span> }
<span class="ruby-identifier">enum</span>.<span class="ruby-identifier">chunk</span>(<span class="ruby-identifier">initial_state</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">elt</span>, <span class="ruby-identifier">state</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span> }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">ary</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span> }
</pre>

<p>For example, consecutive even numbers and odd numbers can be splitted as
follows.</p>

<pre class="ruby">[<span class="ruby-value">3</span>,<span class="ruby-value">1</span>,<span class="ruby-value">4</span>,<span class="ruby-value">1</span>,<span class="ruby-value">5</span>,<span class="ruby-value">9</span>,<span class="ruby-value">2</span>,<span class="ruby-value">6</span>,<span class="ruby-value">5</span>,<span class="ruby-value">3</span>,<span class="ruby-value">5</span>].<span class="ruby-identifier">chunk</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">n</span>.<span class="ruby-identifier">even?</span>
}.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">even</span>, <span class="ruby-identifier">ary</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">p</span> [<span class="ruby-identifier">even</span>, <span class="ruby-identifier">ary</span>]
}
<span class="ruby-comment">#=&gt; [false, [3, 1]]</span>
<span class="ruby-comment">#   [true, [4]]</span>
<span class="ruby-comment">#   [false, [1, 5, 9]]</span>
<span class="ruby-comment">#   [true, [2, 6]]</span>
<span class="ruby-comment">#   [false, [5, 3, 5]]</span>
</pre>

<p>This method is especially useful for sorted series of elements. The
following example counts words for each initial letter.</p>

<pre class="ruby"><span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;/usr/share/dict/words&quot;</span>, <span class="ruby-string">&quot;r:iso-8859-1&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">chunk</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">ord</span> }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> [<span class="ruby-identifier">ch</span>.<span class="ruby-identifier">chr</span>, <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">length</span>] }
}
<span class="ruby-comment">#=&gt; [&quot;\n&quot;, 1]</span>
<span class="ruby-comment">#   [&quot;A&quot;, 1327]</span>
<span class="ruby-comment">#   [&quot;B&quot;, 1372]</span>
<span class="ruby-comment">#   [&quot;C&quot;, 1507]</span>
<span class="ruby-comment">#   [&quot;D&quot;, 791]</span>
<span class="ruby-comment">#   ...</span>
</pre>

<p>The following key values has special meaning:</p>
<ul><li>
<p>nil and :_separator specifies that the elements are dropped.</p>
</li><li>
<p>:_alone specifies that the element should be chunked as a singleton.</p>
</li></ul>

<p>Other symbols which begins an underscore are reserved.</p>

<p>nil and :_separator can be used to ignore some elements. For example, the
sequence of hyphens in svn log can be eliminated as follows.</p>

<pre class="ruby"><span class="ruby-identifier">sep</span> = <span class="ruby-string">&quot;-&quot;</span>*<span class="ruby-value">72</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\n&quot;</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-string">&quot;svn log README&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">chunk</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">line</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">sep</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">nil</span>
  }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">_</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">lines</span>
  }
}
<span class="ruby-comment">#=&gt; [&quot;r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n&quot;,</span>
<span class="ruby-comment">#    &quot;\n&quot;,</span>
<span class="ruby-comment">#    &quot;* README, README.ja: Update the portability section.\n&quot;,</span>
<span class="ruby-comment">#    &quot;\n&quot;]</span>
<span class="ruby-comment">#   [&quot;r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n&quot;,</span>
<span class="ruby-comment">#    &quot;\n&quot;,</span>
<span class="ruby-comment">#    &quot;* README, README.ja: Add a note about default C flags.\n&quot;,</span>
<span class="ruby-comment">#    &quot;\n&quot;]</span>
<span class="ruby-comment">#   ...</span>
</pre>

<p>paragraphs separated by empty lines can be parsed as follows.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">foreach</span>(<span class="ruby-string">&quot;README&quot;</span>).<span class="ruby-identifier">chunk</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
  <span class="ruby-regexp">%r\A\s*\z/</span> <span class="ruby-operator">!~</span> <span class="ruby-identifier">line</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">nil</span>
}.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">_</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">pp</span> <span class="ruby-identifier">lines</span>
}
</pre>

<p>:_alone can be used to pass through bunch of elements. For example, sort
consecutive lines formed as Foo#bar and pass other lines, chunk can be used
as follows.</p>

<pre class="ruby"><span class="ruby-identifier">pat</span> = <span class="ruby-regexp">%r\A[A-Z][A-Za-z0-9_]+\#/</span>
<span class="ruby-identifier">open</span>(<span class="ruby-identifier">filename</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">chunk</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">pat</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">line</span> <span class="ruby-operator">?</span> <span class="ruby-node">$&amp;</span> <span class="ruby-operator">:</span> :<span class="ruby-identifier">_alone</span> }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">lines</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">key</span> <span class="ruby-operator">!=</span> :<span class="ruby-identifier">_alone</span>
      <span class="ruby-identifier">print</span> <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">''</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">print</span> <span class="ruby-identifier">lines</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">''</span>)
    <span class="ruby-keyword">end</span>
  }
}
</pre>

<p>If the block needs to maintain state over multiple elements,
<em>initial_state</em> argument can be used. If non-nil value is given, it
is duplicated for each "each" method invocation of the enumerator. The
duplicated object is passed to 2nd argument of the block for "chunk"
method.</p>
          

          
          <div class="method-source-code" id="chunk-source">
            <pre>static VALUE
enum_chunk(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE initial_state;
    VALUE enumerator;

    if(!rb_block_given_p())
        rb_raise(rb_eArgError, &quot;no block given&quot;);
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;initial_state);

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_enumerable&quot;), enumerable);
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_categorize&quot;), rb_block_proc());
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_initial_state&quot;), initial_state);
    rb_block_call(enumerator, rb_intern(&quot;initialize&quot;), 0, 0, chunk_i, enumerator);
    return enumerator;
}</pre>
          </div><!-- chunk-source -->
          
        </div>

        

        
      </div><!-- chunk-method -->

    
      <div id="method-i-collect" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            collect {| obj | block }  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            map     {| obj | block }  &rarr; array
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            collect                   &rarr; an_enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            map                       &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>*<span class="ruby-identifier">i</span> }   <span class="ruby-comment">#=&gt; [1, 4, 9, 16]</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">collect</span> { <span class="ruby-string">&quot;cat&quot;</span>  }   <span class="ruby-comment">#=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]</span>
</pre>
          

          
          <div class="method-source-code" id="collect-source">
            <pre>static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, collect_i, ary);

    return ary;
}</pre>
          </div><!-- collect-source -->
          
        </div>

        

        
      </div><!-- collect-method -->

    
      <div id="method-i-collect_concat" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            flat_map       {| obj | block }  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            collect_concat {| obj | block }  &rarr; array
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            flat_map                         &rarr; an_enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            collect_concat                   &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">[[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>],[<span class="ruby-value">3</span>,<span class="ruby-value">4</span>]].<span class="ruby-identifier">flat_map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> }   <span class="ruby-comment">#=&gt; [1, 2, 3, 4]</span>
</pre>
          

          
          <div class="method-source-code" id="collect_concat-source">
            <pre>static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</pre>
          </div><!-- collect_concat-source -->
          
        </div>

        

        
      </div><!-- collect_concat-method -->

    
      <div id="method-i-count" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            count                   &rarr; int
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            count(item)             &rarr; int
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            count {| obj | block }  &rarr; int
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the number of items in <em>enum</em>, where size is called if it
responds to it, otherwise the items are counted through enumeration.  If an
argument is given, counts the number of items in <em>enum</em>, for which
equals to <em>item</em>.  If a block is given, counts the number of
elements yielding a true value.</p>

<pre class="ruby"><span class="ruby-identifier">ary</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">4</span>, <span class="ruby-value">2</span>]
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>             <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>(<span class="ruby-value">2</span>)          <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">count</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">%</span><span class="ruby-value">2</span><span class="ruby-operator">==</span><span class="ruby-value">0</span>}  <span class="ruby-comment">#=&gt; 3</span>
</pre>
          

          
          <div class="method-source-code" id="count-source">
            <pre>static VALUE
enum_count(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[2];      /* [count, condition value] */
    rb_block_call_func *func;

    if (argc == 0) {
        if (rb_block_given_p()) {
            func = count_iter_i;
        }
        else {
            func = count_all_i;
        }
    }
    else {
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;memo[1]);
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        func = count_i;
    }

    memo[0] = 0;
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)&amp;memo);
    return INT2NUM(memo[0]);
}</pre>
          </div><!-- count-source -->
          
        </div>

        

        
      </div><!-- count-method -->

    
      <div id="method-i-cycle" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            cycle(n=nil) {|obj| block }   &rarr;  nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            cycle(n=nil)                  &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> for each element of <em>enum</em> repeatedly
<em>n</em> times or forever if none or <code>nil</code> is given.  If a
non-positive number is given or the collection is empty, does nothing. 
Returns <code>nil</code> if the loop has finished without getting
interrupted.</p>

<p><a href="Enumerable.html#method-i-cycle">#cycle</a> saves elements in an
internal array so changes to <em>enum</em> after the first pass have no
effect.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cycle</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">x</span> }  <span class="ruby-comment"># print, a, b, c, a, b, c,.. forever.</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">cycle</span>(<span class="ruby-value">2</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">x</span> }  <span class="ruby-comment"># print, a, b, c, a, b, c.</span>
</pre>
          

          
          <div class="method-source-code" id="cycle-source">
            <pre>static VALUE
enum_cycle(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    VALUE nv = Qnil;
    long n, i, len;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);

    RETURN_ENUMERATOR(obj, argc, argv);
    if (NIL_P(nv)) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }
    ary = rb_ary_new();
    RBASIC(ary)-&gt;klass = 0;
    rb_block_call(obj, id_each, 0, 0, cycle_i, ary);
    len = RARRAY_LEN(ary);
    if (len == 0) return Qnil;
    while (n &lt; 0 || 0 &lt; --n) {
        for (i=0; i&lt;len; i++) {
            rb_yield(RARRAY_PTR(ary)[i]);
        }
    }
    return Qnil;
}</pre>
          </div><!-- cycle-source -->
          
        </div>

        

        
      </div><!-- cycle-method -->

    
      <div id="method-i-detect" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            detect(ifnone = nil) {| obj | block }  &rarr; obj or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            find(ifnone = nil)   {| obj | block }  &rarr; obj or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            detect(ifnone = nil)                   &rarr; an_enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            find(ifnone = nil)                     &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for
which <em>block</em> is not false.  If no object matches, calls
<em>ifnone</em> and returns its result when it is specified, or returns
<code>nil</code> otherwise.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">detect</span>  {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; nil</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 35</span>
</pre>
          

          
          <div class="method-source-code" id="detect-source">
            <pre>static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo = Qundef;
    VALUE if_none;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;if_none);
    RETURN_ENUMERATOR(obj, argc, argv);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)&amp;memo);
    if (memo != Qundef) {
        return memo;
    }
    if (!NIL_P(if_none)) {
        return rb_funcall(if_none, rb_intern(&quot;call&quot;), 0, 0);
    }
    return Qnil;
}</pre>
          </div><!-- detect-source -->
          
        </div>

        

        
      </div><!-- detect-method -->

    
      <div id="method-i-drop" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            drop(n)               &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Drops first n elements from <em>enum</em>, and returns rest elements in an
array.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop</span>(<span class="ruby-value">3</span>)             <span class="ruby-comment">#=&gt; [4, 5, 0]</span>
</pre>
          

          
          <div class="method-source-code" id="drop-source">
            <pre>static VALUE
enum_drop(VALUE obj, VALUE n)
{
    VALUE args[2];
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    args[1] = len;
    args[0] = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, drop_i, (VALUE)args);
    return args[0];
}</pre>
          </div><!-- drop-source -->
          
        </div>

        

        
      </div><!-- drop-method -->

    
      <div id="method-i-drop_while" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            drop_while {|arr| block }   &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            drop_while                  &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Drops elements up to, but not including, the first element for which the
block returns <code>nil</code> or <code>false</code> and returns an array
containing the remaining elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">drop_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> }   <span class="ruby-comment">#=&gt; [3, 4, 5, 0]</span>
</pre>
          

          
          <div class="method-source-code" id="drop_while-source">
            <pre>static VALUE
enum_drop_while(VALUE obj)
{
    VALUE args[2];

    RETURN_ENUMERATOR(obj, 0, 0);
    args[0] = rb_ary_new();
    args[1] = Qfalse;
    rb_block_call(obj, id_each, 0, 0, drop_while_i, (VALUE)args);
    return args[0];
}</pre>
          </div><!-- drop_while-source -->
          
        </div>

        

        
      </div><!-- drop_while-method -->

    
      <div id="method-i-each_cons" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            each_cons(n) {...}   &rarr;  nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            each_cons(n)         &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterates the given block for each array of consecutive &lt;n&gt; elements. 
If no block is given, returns an enumerator.</p>

<p>e.g.:</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">each_cons</span>(<span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>}
<span class="ruby-comment"># outputs below</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
[<span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>]
[<span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>]
[<span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
[<span class="ruby-value">5</span>, <span class="ruby-value">6</span>, <span class="ruby-value">7</span>]
[<span class="ruby-value">6</span>, <span class="ruby-value">7</span>, <span class="ruby-value">8</span>]
[<span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>]
[<span class="ruby-value">8</span>, <span class="ruby-value">9</span>, <span class="ruby-value">10</span>]
</pre>
          

          
          <div class="method-source-code" id="each_cons-source">
            <pre>static VALUE
enum_each_cons(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    VALUE args[2];

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid size&quot;);
    RETURN_ENUMERATOR(obj, 1, &amp;n);
    args[0] = rb_ary_new2(size);
    args[1] = (VALUE)size;

    rb_block_call(obj, id_each, 0, 0, each_cons_i, (VALUE)args);

    return Qnil;
}</pre>
          </div><!-- each_cons-source -->
          
        </div>

        

        
      </div><!-- each_cons-method -->

    
      <div id="method-i-each_entry" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            each_entry {|obj| block}  &rarr; enum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            each_entry                &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> once for each element in <code>self</code>, passing
that element as a parameter, converting multiple values from yield to an
array.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Foo</span>
  <span class="ruby-identifier">include</span> <span class="ruby-constant">Enumerable</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">each</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-value">1</span>,<span class="ruby-value">2</span>
    <span class="ruby-keyword">yield</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-constant">Foo</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">each_entry</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">o</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">o</span> }
</pre>

<p>produces:</p>

<pre>1
[1, 2]
nil</pre>
          

          
          <div class="method-source-code" id="each_entry-source">
            <pre>static VALUE
enum_each_entry(int argc, VALUE *argv, VALUE obj)
{
    RETURN_ENUMERATOR(obj, argc, argv);
    rb_block_call(obj, id_each, argc, argv, each_val_i, 0);
    return obj;
}</pre>
          </div><!-- each_entry-source -->
          
        </div>

        

        
      </div><!-- each_entry-method -->

    
      <div id="method-i-each_slice" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            each_slice(n) {...}  &rarr;  nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            each_slice(n)        &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterates the given block for each slice of &lt;n&gt; elements.  If no block
is given, returns an enumerator.</p>

<p>e.g.:</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">each_slice</span>(<span class="ruby-value">3</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>}
<span class="ruby-comment"># outputs below</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
[<span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>]
[<span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span>]
[<span class="ruby-value">10</span>]
</pre>
          

          
          <div class="method-source-code" id="each_slice-source">
            <pre>static VALUE
enum_each_slice(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    VALUE args[2], ary;

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid slice size&quot;);
    RETURN_ENUMERATOR(obj, 1, &amp;n);
    args[0] = rb_ary_new2(size);
    args[1] = (VALUE)size;

    rb_block_call(obj, id_each, 0, 0, each_slice_i, (VALUE)args);

    ary = args[0];
    if (RARRAY_LEN(ary) &gt; 0) rb_yield(ary);

    return Qnil;
}</pre>
          </div><!-- each_slice-source -->
          
        </div>

        

        
      </div><!-- each_slice-method -->

    
      <div id="method-i-each_with_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            each_with_index(*args) {|obj, i| block }   &rarr;  enum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            each_with_index(*args)                     &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calls <em>block</em> with two arguments, the item and its index, for each
item in <em>enum</em>.  Given arguments are passed through to each().</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">hash</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
<span class="ruby-node">%w(cat dog wombat)</span>.<span class="ruby-identifier">each_with_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">item</span>, <span class="ruby-identifier">index</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">hash</span>[<span class="ruby-identifier">item</span>] = <span class="ruby-identifier">index</span>
}
<span class="ruby-identifier">hash</span>   <span class="ruby-comment">#=&gt; {&quot;cat&quot;=&gt;0, &quot;dog&quot;=&gt;1, &quot;wombat&quot;=&gt;2}</span>
</pre>
          

          
          <div class="method-source-code" id="each_with_index-source">
            <pre>static VALUE
enum_each_with_index(int argc, VALUE *argv, VALUE obj)
{
    long memo;

    RETURN_ENUMERATOR(obj, argc, argv);

    memo = 0;
    rb_block_call(obj, id_each, argc, argv, each_with_index_i, (VALUE)&amp;memo);
    return obj;
}</pre>
          </div><!-- each_with_index-source -->
          
        </div>

        

        
      </div><!-- each_with_index-method -->

    
      <div id="method-i-each_with_object" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            each_with_object(obj) {|(*args), memo_obj| ... }  &rarr;  obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            each_with_object(obj)                             &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterates the given block for each element with an arbitrary object given,
and returns the initially given object.</p>

<p>If no block is given, returns an enumerator.</p>

<p>e.g.:</p>

<pre class="ruby"><span class="ruby-identifier">evens</span> = (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">each_with_object</span>([]) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span>, <span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">i</span>*<span class="ruby-value">2</span> }
<span class="ruby-comment">#=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span>
</pre>
          

          
          <div class="method-source-code" id="each_with_object-source">
            <pre>static VALUE
enum_each_with_object(VALUE obj, VALUE memo)
{
    RETURN_ENUMERATOR(obj, 1, &amp;memo);

    rb_block_call(obj, id_each, 0, 0, each_with_object_i, memo);

    return memo;
}</pre>
          </div><!-- each_with_object-source -->
          
        </div>

        

        
      </div><!-- each_with_object-method -->

    
      <div id="method-i-entries" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            to_a      &rarr;    array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            entries   &rarr;    array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array containing the items in <em>enum</em>.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">7</span>).<span class="ruby-identifier">to_a</span>                       <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6, 7]</span>
{ <span class="ruby-string">'a'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, <span class="ruby-string">'b'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>, <span class="ruby-string">'c'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">3</span> }.<span class="ruby-identifier">to_a</span>   <span class="ruby-comment">#=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]</span>
</pre>
          

          
          <div class="method-source-code" id="entries-source">
            <pre>static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);
    OBJ_INFECT(ary, obj);

    return ary;
}</pre>
          </div><!-- entries-source -->
          
        </div>

        

        
      </div><!-- entries-method -->

    
      <div id="method-i-find" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            detect(ifnone = nil) {| obj | block }  &rarr; obj or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            find(ifnone = nil)   {| obj | block }  &rarr; obj or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            detect(ifnone = nil)                   &rarr; an_enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            find(ifnone = nil)                     &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for
which <em>block</em> is not false.  If no object matches, calls
<em>ifnone</em> and returns its result when it is specified, or returns
<code>nil</code> otherwise.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">detect</span>  {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; nil</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">detect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 35</span>
</pre>
          

          
          <div class="method-source-code" id="find-source">
            <pre>static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo = Qundef;
    VALUE if_none;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;if_none);
    RETURN_ENUMERATOR(obj, argc, argv);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)&amp;memo);
    if (memo != Qundef) {
        return memo;
    }
    if (!NIL_P(if_none)) {
        return rb_funcall(if_none, rb_intern(&quot;call&quot;), 0, 0);
    }
    return Qnil;
}</pre>
          </div><!-- find-source -->
          
        </div>

        

        
      </div><!-- find-method -->

    
      <div id="method-i-find_all" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            find_all {| obj | block }  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            select   {| obj | block }  &rarr; array
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            find_all                   &rarr; an_enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            select                     &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array containing all elements of <em>enum</em> for which
<em>block</em> is not <code>false</code> (see also
<code>Enumerable#reject</code>).</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find_all</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">3</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; [3, 6, 9]</span>
</pre>
          

          
          <div class="method-source-code" id="find_all-source">
            <pre>static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</pre>
          </div><!-- find_all-source -->
          
        </div>

        

        
      </div><!-- find_all-method -->

    
      <div id="method-i-find_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            find_index(value)            &rarr; int or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            find_index {| obj | block }  &rarr; int or nil
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            find_index                   &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compares each entry in <em>enum</em> with <em>value</em> or passes to
<em>block</em>.  Returns the index for the first for which the evaluated
value is non-false.  If no object matches, returns <code>nil</code></p>

<p>If neither block nor argument is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find_index</span>  {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; nil</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">5</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">7</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; 34</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">find_index</span>(<span class="ruby-value">50</span>)                                <span class="ruby-comment">#=&gt; 49</span>
</pre>
          

          
          <div class="method-source-code" id="find_index-source">
            <pre>static VALUE
enum_find_index(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[3];      /* [return value, current index, condition value] */
    rb_block_call_func *func;

    if (argc == 0) {
        RETURN_ENUMERATOR(obj, 0, 0);
        func = find_index_iter_i;
    }
    else {
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;memo[2]);
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        func = find_index_i;
    }

    memo[0] = Qnil;
    memo[1] = 0;
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return memo[0];
}</pre>
          </div><!-- find_index-source -->
          
        </div>

        

        
      </div><!-- find_index-method -->

    
      <div id="method-i-first" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            first       &rarr;  obj or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            first(n)    &rarr;  an_array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the first element, or the first <code>n</code> elements, of the
enumerable. If the enumerable is empty, the first form returns
<code>nil</code>, and the second form returns an empty array.</p>

<pre class="ruby"><span class="ruby-node">%w[foo bar baz]</span>.<span class="ruby-identifier">first</span>     <span class="ruby-comment">#=&gt; &quot;foo&quot;</span>
<span class="ruby-node">%w[foo bar baz]</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">2</span>)  <span class="ruby-comment">#=&gt; [&quot;foo&quot;, &quot;bar&quot;]</span>
<span class="ruby-node">%w[foo bar baz]</span>.<span class="ruby-identifier">first</span>(<span class="ruby-value">10</span>) <span class="ruby-comment">#=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
[].<span class="ruby-identifier">first</span>                  <span class="ruby-comment">#=&gt; nil</span>
</pre>
          

          
          <div class="method-source-code" id="first-source">
            <pre>static VALUE
enum_first(int argc, VALUE *argv, VALUE obj)
{
    VALUE n, params[2];

    if (argc == 0) {
        params[0] = params[1] = Qnil;
    }
    else {
        long len;

        rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);
        len = NUM2LONG(n);
        if (len == 0) return rb_ary_new2(0);
        if (len &lt; 0) {
            rb_raise(rb_eArgError, &quot;negative length&quot;);
        }
        params[0] = len;
        params[1] = rb_ary_new2(len);
    }
    rb_block_call(obj, id_each, 0, 0, first_i, (VALUE)params);

    return params[1];
}</pre>
          </div><!-- first-source -->
          
        </div>

        

        
      </div><!-- first-method -->

    
      <div id="method-i-flat_map" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            flat_map       {| obj | block }  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            collect_concat {| obj | block }  &rarr; array
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            flat_map                         &rarr; an_enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            collect_concat                   &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">[[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>],[<span class="ruby-value">3</span>,<span class="ruby-value">4</span>]].<span class="ruby-identifier">flat_map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> }   <span class="ruby-comment">#=&gt; [1, 2, 3, 4]</span>
</pre>
          

          
          <div class="method-source-code" id="flat_map-source">
            <pre>static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</pre>
          </div><!-- flat_map-source -->
          
        </div>

        

        
      </div><!-- flat_map-method -->

    
      <div id="method-i-grep" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            grep(pattern)                   &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            grep(pattern) {| obj | block }  &rarr; array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array of every element in <em>enum</em> for which <code>Pattern
=== element</code>. If the optional <em>block</em> is supplied, each
matching element is passed to it, and the block's result is stored in the
output array.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100</span>).<span class="ruby-identifier">grep</span> <span class="ruby-value">38</span><span class="ruby-operator">..</span><span class="ruby-value">44</span>   <span class="ruby-comment">#=&gt; [38, 39, 40, 41, 42, 43, 44]</span>
<span class="ruby-identifier">c</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">constants</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">grep</span>(<span class="ruby-regexp">%rSEEK/</span>)         <span class="ruby-comment">#=&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]</span>
<span class="ruby-identifier">res</span> = <span class="ruby-identifier">c</span>.<span class="ruby-identifier">grep</span>(<span class="ruby-regexp">%rSEEK/</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-constant">IO</span>.<span class="ruby-identifier">const_get</span>(<span class="ruby-identifier">v</span>) }
<span class="ruby-identifier">res</span>                    <span class="ruby-comment">#=&gt; [0, 1, 2]</span>
</pre>
          

          
          <div class="method-source-code" id="grep-source">
            <pre>static VALUE
enum_grep(VALUE obj, VALUE pat)
{
    VALUE ary = rb_ary_new();
    VALUE arg[2];

    arg[0] = pat;
    arg[1] = ary;

    rb_block_call(obj, id_each, 0, 0, rb_block_given_p() ? grep_iter_i : grep_i, (VALUE)arg);

    return ary;
}</pre>
          </div><!-- grep-source -->
          
        </div>

        

        
      </div><!-- grep-method -->

    
      <div id="method-i-group_by" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            group_by {| obj | block }  &rarr; a_hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            group_by                   &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a hash, which keys are evaluated result from the block, and values
are arrays of elements in <em>enum</em> corresponding to the key.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">6</span>).<span class="ruby-identifier">group_by</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">%</span><span class="ruby-value">3</span>}   <span class="ruby-comment">#=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}</span>
</pre>
          

          
          <div class="method-source-code" id="group_by-source">
            <pre>static VALUE
enum_group_by(VALUE obj)
{
    VALUE hash;

    RETURN_ENUMERATOR(obj, 0, 0);

    hash = rb_hash_new();
    rb_block_call(obj, id_each, 0, 0, group_by_i, hash);
    OBJ_INFECT(hash, obj);

    return hash;
}</pre>
          </div><!-- group_by-source -->
          
        </div>

        

        
      </div><!-- group_by-method -->

    
      <div id="method-i-include-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            include?(obj)     &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            member?(obj)      &rarr; true or false
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if any member of <em>enum</em> equals
<em>obj</em>. Equality is tested using <code>==</code>.</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">constants</span>.<span class="ruby-identifier">include?</span> :<span class="ruby-constant">SEEK_SET</span>          <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">constants</span>.<span class="ruby-identifier">include?</span> :<span class="ruby-constant">SEEK_NO_FURTHER</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>
          

          
          <div class="method-source-code" id="include-3F-source">
            <pre>static VALUE
enum_member(VALUE obj, VALUE val)
{
    VALUE memo[2];

    memo[0] = val;
    memo[1] = Qfalse;
    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo[1];
}</pre>
          </div><!-- include-3F-source -->
          
        </div>

        

        
      </div><!-- include-3F-method -->

    
      <div id="method-i-inject" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            inject(initial, sym) &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            inject(sym)          &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            inject(initial) {| memo, obj | block }  &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            inject          {| memo, obj | block }  &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            reduce(initial, sym) &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            reduce(sym)          &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            reduce(initial) {| memo, obj | block }  &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            reduce          {| memo, obj | block }  &rarr; obj
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Combines all elements of <em>enum</em> by applying a binary operation,
specified by a block or a symbol that names a method or operator.</p>

<p>If you specify a block, then for each element in <em>enum</em> the block is
passed an accumulator value (<em>memo</em>) and the element. If you specify
a symbol instead, then each element in the collection will be passed to the
named method of <em>memo</em>. In either case, the result becomes the new
value for <em>memo</em>. At the end of the iteration, the final value of
<em>memo</em> is the return value for the method.</p>

<p>If you do not explicitly specify an <em>initial</em> value for
<em>memo</em>, then uses the first element of collection is used as the
initial value of <em>memo</em>.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-comment"># Sum some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(:<span class="ruby-operator">+</span>)                            <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Same using a block and inject</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">n</span> }            <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Multiply some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(<span class="ruby-value">1</span>, :*)                         <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># Same using a block</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span>(<span class="ruby-value">1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">product</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">product</span> * <span class="ruby-identifier">n</span> } <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># find the longest word</span>
<span class="ruby-identifier">longest</span> = <span class="ruby-node">%w{ cat sheep bear }</span>.<span class="ruby-identifier">inject</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">memo</span>,<span class="ruby-identifier">word</span><span class="ruby-operator">|</span>
   <span class="ruby-identifier">memo</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">memo</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">word</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">longest</span>                                       <span class="ruby-comment">#=&gt; &quot;sheep&quot;</span>
</pre>
          

          
          <div class="method-source-code" id="inject-source">
            <pre>static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[2];
    VALUE (*iter)(VALUE, VALUE, int, VALUE*) = inject_i;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;memo[0], &amp;memo[1])) {
      case 0:
        memo[0] = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        memo[1] = (VALUE)rb_to_id(memo[0]);
        memo[0] = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        memo[1] = (VALUE)rb_to_id(memo[1]);
        iter = inject_op_i;
        break;
    }
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo[0] == Qundef) return Qnil;
    return memo[0];
}</pre>
          </div><!-- inject-source -->
          
        </div>

        

        
      </div><!-- inject-method -->

    
      <div id="method-i-map" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            collect {| obj | block }  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            map     {| obj | block }  &rarr; array
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            collect                   &rarr; an_enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            map                       &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>*<span class="ruby-identifier">i</span> }   <span class="ruby-comment">#=&gt; [1, 4, 9, 16]</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>).<span class="ruby-identifier">collect</span> { <span class="ruby-string">&quot;cat&quot;</span>  }   <span class="ruby-comment">#=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]</span>
</pre>
          

          
          <div class="method-source-code" id="map-source">
            <pre>static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, collect_i, ary);

    return ary;
}</pre>
          </div><!-- map-source -->
          
        </div>

        

        
      </div><!-- map-method -->

    
      <div id="method-i-max" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            max                   &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            max {|a,b| block }    &rarr; obj
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the object in <em>enum</em> with the maximum value. The first form
assumes all objects implement <code>Comparable</code>; the second uses the
block to return <em>a &lt;=&gt; b</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max</span>                                  <span class="ruby-comment">#=&gt; &quot;horse&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; &quot;albatross&quot;</span>
</pre>
          

          
          <div class="method-source-code" id="max-source">
            <pre>static VALUE
enum_max(VALUE obj)
{
    VALUE result = Qundef;

    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)&amp;result);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, max_i, (VALUE)&amp;result);
    }
    if (result == Qundef) return Qnil;
    return result;
}</pre>
          </div><!-- max-source -->
          
        </div>

        

        
      </div><!-- max-method -->

    
      <div id="method-i-max_by" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            max_by {|obj| block }   &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            max_by                  &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the object in <em>enum</em> that gives the maximum value from the
given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">max_by</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; &quot;albatross&quot;</span>
</pre>
          

          
          <div class="method-source-code" id="max_by-source">
            <pre>static VALUE
enum_max_by(VALUE obj)
{
    VALUE memo[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    memo[0] = Qundef;
    memo[1] = Qnil;
    rb_block_call(obj, id_each, 0, 0, max_by_i, (VALUE)memo);
    return memo[1];
}</pre>
          </div><!-- max_by-source -->
          
        </div>

        

        
      </div><!-- max_by-method -->

    
      <div id="method-i-member-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            include?(obj)     &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            member?(obj)      &rarr; true or false
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if any member of <em>enum</em> equals
<em>obj</em>. Equality is tested using <code>==</code>.</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">constants</span>.<span class="ruby-identifier">include?</span> :<span class="ruby-constant">SEEK_SET</span>          <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">constants</span>.<span class="ruby-identifier">include?</span> :<span class="ruby-constant">SEEK_NO_FURTHER</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>
          

          
          <div class="method-source-code" id="member-3F-source">
            <pre>static VALUE
enum_member(VALUE obj, VALUE val)
{
    VALUE memo[2];

    memo[0] = val;
    memo[1] = Qfalse;
    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo[1];
}</pre>
          </div><!-- member-3F-source -->
          
        </div>

        

        
      </div><!-- member-3F-method -->

    
      <div id="method-i-min" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            min                    &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            min {| a,b | block }   &rarr; obj
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the object in <em>enum</em> with the minimum value. The first form
assumes all objects implement <code>Comparable</code>; the second uses the
block to return <em>a &lt;=&gt; b</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min</span>                                  <span class="ruby-comment">#=&gt; &quot;albatross&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; &quot;dog&quot;</span>
</pre>
          

          
          <div class="method-source-code" id="min-source">
            <pre>static VALUE
enum_min(VALUE obj)
{
    VALUE result = Qundef;

    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, min_ii, (VALUE)&amp;result);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, min_i, (VALUE)&amp;result);
    }
    if (result == Qundef) return Qnil;
    return result;
}</pre>
          </div><!-- min-source -->
          
        </div>

        

        
      </div><!-- min-method -->

    
      <div id="method-i-min_by" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            min_by {|obj| block }   &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            min_by                  &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the object in <em>enum</em> that gives the minimum value from the
given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">min_by</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; &quot;dog&quot;</span>
</pre>
          

          
          <div class="method-source-code" id="min_by-source">
            <pre>static VALUE
enum_min_by(VALUE obj)
{
    VALUE memo[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    memo[0] = Qundef;
    memo[1] = Qnil;
    rb_block_call(obj, id_each, 0, 0, min_by_i, (VALUE)memo);
    return memo[1];
}</pre>
          </div><!-- min_by-source -->
          
        </div>

        

        
      </div><!-- min_by-method -->

    
      <div id="method-i-minmax" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            minmax                   &rarr; [min,max]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            minmax {|a,b| block }    &rarr; [min,max]
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns two elements array which contains the minimum and the maximum value
in the enumerable.  The first form assumes all objects implement
<code>Comparable</code>; the second uses the block to return <em>a
&lt;=&gt; b</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">minmax</span>                                  <span class="ruby-comment">#=&gt; [&quot;albatross&quot;, &quot;horse&quot;]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">minmax</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; [&quot;dog&quot;, &quot;albatross&quot;]</span>
</pre>
          

          
          <div class="method-source-code" id="minmax-source">
            <pre>static VALUE
enum_minmax(VALUE obj)
{
    struct minmax_t memo;
    VALUE ary = rb_ary_new3(2, Qnil, Qnil);

    memo.min = Qundef;
    memo.last = Qundef;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, minmax_ii, (VALUE)&amp;memo);
        if (memo.last != Qundef)
            minmax_ii_update(memo.last, memo.last, &amp;memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, minmax_i, (VALUE)&amp;memo);
        if (memo.last != Qundef)
            minmax_i_update(memo.last, memo.last, &amp;memo);
    }
    if (memo.min != Qundef) {
        rb_ary_store(ary, 0, memo.min);
        rb_ary_store(ary, 1, memo.max);
    }
    return ary;
}</pre>
          </div><!-- minmax-source -->
          
        </div>

        

        
      </div><!-- minmax-method -->

    
      <div id="method-i-minmax_by" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            minmax_by {|obj| block }   &rarr; [min, max]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            minmax_by                  &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns two elements array array containing the objects in <em>enum</em>
that gives the minimum and maximum values respectively from the given
block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-node">%w(albatross dog horse)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">minmax_by</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">length</span> }   <span class="ruby-comment">#=&gt; [&quot;dog&quot;, &quot;albatross&quot;]</span>
</pre>
          

          
          <div class="method-source-code" id="minmax_by-source">
            <pre>static VALUE
enum_minmax_by(VALUE obj)
{
    struct minmax_by_t memo;

    RETURN_ENUMERATOR(obj, 0, 0);

    memo.min_bv = Qundef;
    memo.max_bv = Qundef;
    memo.min = Qnil;
    memo.max = Qnil;
    memo.last_bv = Qundef;
    memo.last = Qundef;
    rb_block_call(obj, id_each, 0, 0, minmax_by_i, (VALUE)&amp;memo);
    if (memo.last_bv != Qundef)
        minmax_by_i_update(memo.last_bv, memo.last_bv, memo.last, memo.last, &amp;memo);
    return rb_assoc_new(memo.min, memo.max);
}</pre>
          </div><!-- minmax_by-source -->
          
        </div>

        

        
      </div><!-- minmax_by-method -->

    
      <div id="method-i-none-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            none? [{|obj| block }]   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block never returns <code>true</code> for
all elements. If the block is not given, <code>none?</code> will return
<code>true</code> only if none of the collection members is true.</p>

<pre class="ruby"><span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">none?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">5</span>}  <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">none?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">4</span>}  <span class="ruby-comment">#=&gt; false</span>
[].<span class="ruby-identifier">none?</span>                                          <span class="ruby-comment">#=&gt; true</span>
[<span class="ruby-keyword">nil</span>].<span class="ruby-identifier">none?</span>                                       <span class="ruby-comment">#=&gt; true</span>
[<span class="ruby-keyword">nil</span>,<span class="ruby-keyword">false</span>].<span class="ruby-identifier">none?</span>                                 <span class="ruby-comment">#=&gt; true</span>
</pre>
          

          
          <div class="method-source-code" id="none-3F-source">
            <pre>static VALUE
enum_none(VALUE obj)
{
    VALUE result = Qtrue;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(none), (VALUE)&amp;result);
    return result;
}</pre>
          </div><!-- none-3F-source -->
          
        </div>

        

        
      </div><!-- none-3F-method -->

    
      <div id="method-i-one-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            one? [{|obj| block }]   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes each element of the collection to the given block. The method
returns <code>true</code> if the block returns <code>true</code> exactly
once. If the block is not given, <code>one?</code> will return
<code>true</code> only if exactly one of the collection members is true.</p>

<pre class="ruby"><span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">one?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">4</span>}   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">one?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">4</span>}    <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-node">%w{ant bear cat}</span>.<span class="ruby-identifier">one?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">4</span>}    <span class="ruby-comment">#=&gt; false</span>
[ <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-value">99</span> ].<span class="ruby-identifier">one?</span>                            <span class="ruby-comment">#=&gt; false</span>
[ <span class="ruby-keyword">nil</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">false</span> ].<span class="ruby-identifier">one?</span>                         <span class="ruby-comment">#=&gt; true</span>
</pre>
          

          
          <div class="method-source-code" id="one-3F-source">
            <pre>static VALUE
enum_one(VALUE obj)
{
    VALUE result = Qundef;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(one), (VALUE)&amp;result);
    if (result == Qundef) return Qfalse;
    return result;
}</pre>
          </div><!-- one-3F-source -->
          
        </div>

        

        
      </div><!-- one-3F-method -->

    
      <div id="method-i-partition" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            partition {| obj | block }  &rarr; [ true_array, false_array ]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            partition                   &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns two arrays, the first containing the elements of <em>enum</em> for
which the block evaluates to true, the second containing the rest.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">6</span>).<span class="ruby-identifier">partition</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">even?</span> }  <span class="ruby-comment">#=&gt; [[2, 4, 6], [1, 3, 5]]</span>
</pre>
          

          
          <div class="method-source-code" id="partition-source">
            <pre>static VALUE
enum_partition(VALUE obj)
{
    VALUE ary[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    ary[0] = rb_ary_new();
    ary[1] = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, partition_i, (VALUE)ary);

    return rb_assoc_new(ary[0], ary[1]);
}</pre>
          </div><!-- partition-source -->
          
        </div>

        

        
      </div><!-- partition-method -->

    
      <div id="method-i-reduce" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            inject(initial, sym) &rarr; obj
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            inject(sym)          &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            inject(initial) {| memo, obj | block }  &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            inject          {| memo, obj | block }  &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            reduce(initial, sym) &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            reduce(sym)          &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            reduce(initial) {| memo, obj | block }  &rarr; obj
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            reduce          {| memo, obj | block }  &rarr; obj
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Combines all elements of <em>enum</em> by applying a binary operation,
specified by a block or a symbol that names a method or operator.</p>

<p>If you specify a block, then for each element in <em>enum</em> the block is
passed an accumulator value (<em>memo</em>) and the element. If you specify
a symbol instead, then each element in the collection will be passed to the
named method of <em>memo</em>. In either case, the result becomes the new
value for <em>memo</em>. At the end of the iteration, the final value of
<em>memo</em> is the return value for the method.</p>

<p>If you do not explicitly specify an <em>initial</em> value for
<em>memo</em>, then uses the first element of collection is used as the
initial value of <em>memo</em>.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-comment"># Sum some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(:<span class="ruby-operator">+</span>)                            <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Same using a block and inject</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">n</span> }            <span class="ruby-comment">#=&gt; 45</span>
<span class="ruby-comment"># Multiply some numbers</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reduce</span>(<span class="ruby-value">1</span>, :*)                         <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># Same using a block</span>
(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">inject</span>(<span class="ruby-value">1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">product</span>, <span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">product</span> * <span class="ruby-identifier">n</span> } <span class="ruby-comment">#=&gt; 151200</span>
<span class="ruby-comment"># find the longest word</span>
<span class="ruby-identifier">longest</span> = <span class="ruby-node">%w{ cat sheep bear }</span>.<span class="ruby-identifier">inject</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">memo</span>,<span class="ruby-identifier">word</span><span class="ruby-operator">|</span>
   <span class="ruby-identifier">memo</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">memo</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">word</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">longest</span>                                       <span class="ruby-comment">#=&gt; &quot;sheep&quot;</span>
</pre>
          

          
          <div class="method-source-code" id="reduce-source">
            <pre>static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[2];
    VALUE (*iter)(VALUE, VALUE, int, VALUE*) = inject_i;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;memo[0], &amp;memo[1])) {
      case 0:
        memo[0] = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        memo[1] = (VALUE)rb_to_id(memo[0]);
        memo[0] = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        memo[1] = (VALUE)rb_to_id(memo[1]);
        iter = inject_op_i;
        break;
    }
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo[0] == Qundef) return Qnil;
    return memo[0];
}</pre>
          </div><!-- reduce-source -->
          
        </div>

        

        
      </div><!-- reduce-method -->

    
      <div id="method-i-reject" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            reject {| obj | block }  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            reject                   &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array for all elements of <em>enum</em> for which <em>block</em>
is false (see also <code>Enumerable#find_all</code>).</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">reject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">3</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; [1, 2, 4, 5, 7, 8, 10]</span>
</pre>
          

          
          <div class="method-source-code" id="reject-source">
            <pre>static VALUE
enum_reject(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, reject_i, ary);

    return ary;
}</pre>
          </div><!-- reject-source -->
          
        </div>

        

        
      </div><!-- reject-method -->

    
      <div id="method-i-reverse_each" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            reverse_each(*args) {|item| block }   &rarr;  enum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            reverse_each(*args)                   &rarr;  an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Builds a temporary array and traverses that array in reverse order.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">  (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>).<span class="ruby-identifier">reverse_each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">v</span> }

<span class="ruby-identifier">produces</span><span class="ruby-operator">:</span>

  <span class="ruby-value">3</span>
  <span class="ruby-value">2</span>
  <span class="ruby-value">1</span>
</pre>
          

          
          <div class="method-source-code" id="reverse_each-source">
            <pre>static VALUE
enum_reverse_each(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    long i;

    RETURN_ENUMERATOR(obj, argc, argv);

    ary = enum_to_a(argc, argv, obj);

    for (i = RARRAY_LEN(ary); --i &gt;= 0; ) {
        rb_yield(RARRAY_PTR(ary)[i]);
    }

    return obj;
}</pre>
          </div><!-- reverse_each-source -->
          
        </div>

        

        
      </div><!-- reverse_each-method -->

    
      <div id="method-i-select" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            find_all {| obj | block }  &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            select   {| obj | block }  &rarr; array
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            find_all                   &rarr; an_enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            select                     &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array containing all elements of <em>enum</em> for which
<em>block</em> is not <code>false</code> (see also
<code>Enumerable#reject</code>).</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">find_all</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>  <span class="ruby-identifier">i</span> <span class="ruby-operator">%</span> <span class="ruby-value">3</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> }   <span class="ruby-comment">#=&gt; [3, 6, 9]</span>
</pre>
          

          
          <div class="method-source-code" id="select-source">
            <pre>static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</pre>
          </div><!-- select-source -->
          
        </div>

        

        
      </div><!-- select-method -->

    
      <div id="method-i-slice_before" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            slice_before(pattern)                            &rarr; an_enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            slice_before {|elt| bool }                       &rarr; an_enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            slice_before(initial_state) {|elt, state| bool } &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <pre class="ruby"><span class="ruby-constant">Creates</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">enumerator</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">each</span> <span class="ruby-identifier">chunked</span> <span class="ruby-identifier">elements</span>.
<span class="ruby-constant">The</span> <span class="ruby-identifier">beginnings</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">chunks</span> <span class="ruby-identifier">are</span> <span class="ruby-identifier">defined</span> <span class="ruby-identifier">by</span> <span class="ruby-identifier">_pattern_</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">block</span>.
<span class="ruby-constant">If</span> <span class="ruby-identifier">_pattern_</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">_elt_</span> <span class="ruby-identifier">returns</span> <span class="ruby-keyword">true</span> <span class="ruby-keyword">or</span>
<span class="ruby-identifier">the</span> <span class="ruby-identifier">block</span> <span class="ruby-identifier">returns</span> <span class="ruby-keyword">true</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">element</span>,
<span class="ruby-identifier">the</span> <span class="ruby-identifier">element</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">beginning</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">chunk</span>.

<span class="ruby-constant">The</span> <span class="ruby-operator">===</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">block</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">called</span> <span class="ruby-identifier">from</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">first</span> <span class="ruby-identifier">element</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">last</span> <span class="ruby-identifier">element</span>
<span class="ruby-identifier">of</span> <span class="ruby-identifier">_enum_</span>.
<span class="ruby-constant">The</span> <span class="ruby-identifier">result</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">first</span> <span class="ruby-identifier">element</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">ignored</span>.

<span class="ruby-constant">The</span> <span class="ruby-identifier">result</span> <span class="ruby-identifier">enumerator</span> <span class="ruby-identifier">yields</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">chunked</span> <span class="ruby-identifier">elements</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">an</span> <span class="ruby-identifier">array</span> <span class="ruby-keyword">for</span> <span class="ruby-operator">+</span><span class="ruby-identifier">each</span><span class="ruby-operator">+</span>
<span class="ruby-identifier">method</span>.
<span class="ruby-operator">+</span><span class="ruby-identifier">each</span><span class="ruby-operator">+</span> <span class="ruby-identifier">method</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">called</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">follows</span>.

  <span class="ruby-identifier">enum</span>.<span class="ruby-identifier">slice_before</span>(<span class="ruby-identifier">pattern</span>).<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ary</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span> }
  <span class="ruby-identifier">enum</span>.<span class="ruby-identifier">slice_before</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">elt</span><span class="ruby-operator">|</span> <span class="ruby-identifier">bool</span> }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ary</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span> }
  <span class="ruby-identifier">enum</span>.<span class="ruby-identifier">slice_before</span>(<span class="ruby-identifier">initial_state</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">elt</span>, <span class="ruby-identifier">state</span><span class="ruby-operator">|</span> <span class="ruby-identifier">bool</span> }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ary</span><span class="ruby-operator">|</span> <span class="ruby-operator">...</span> }

<span class="ruby-constant">Other</span> <span class="ruby-identifier">methods</span> <span class="ruby-identifier">of</span> <span class="ruby-constant">Enumerator</span> <span class="ruby-keyword">class</span> <span class="ruby-keyword">and</span> <span class="ruby-constant">Enumerable</span> <span class="ruby-keyword">module</span>,
<span class="ruby-identifier">such</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">map</span>, <span class="ruby-identifier">etc</span>., <span class="ruby-identifier">are</span> <span class="ruby-identifier">also</span> <span class="ruby-identifier">usable</span>.

<span class="ruby-constant">For</span> <span class="ruby-identifier">example</span>, <span class="ruby-identifier">iteration</span> <span class="ruby-identifier">over</span> <span class="ruby-constant">ChangeLog</span> <span class="ruby-identifier">entries</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">implemented</span> <span class="ruby-identifier">as</span>
<span class="ruby-identifier">follows</span>.

  <span class="ruby-comment"># iterate over ChangeLog entries.</span>
  <span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;ChangeLog&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span>(<span class="ruby-regexp">%r\A\S/</span>).<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">pp</span> <span class="ruby-identifier">e</span>}
  }

  <span class="ruby-comment"># same as above.  block is used instead of pattern argument.</span>
  <span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;ChangeLog&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-regexp">%r\A\S/</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">line</span> }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">pp</span> <span class="ruby-identifier">e</span>}
  }
</pre>

<p>"svn proplist -R" produces multiline output for each file. They can be
chunked as follows:</p>

<pre class="ruby">  <span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>([{<span class="ruby-string">&quot;LC_ALL&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;C&quot;</span>}, <span class="ruby-string">&quot;svn&quot;</span>, <span class="ruby-string">&quot;proplist&quot;</span>, <span class="ruby-string">&quot;-R&quot;</span>]) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">lines</span>.<span class="ruby-identifier">slice_before</span>(<span class="ruby-regexp">%r\AProp/</span>).<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">lines</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">lines</span> }
  }
  <span class="ruby-comment">#=&gt; [&quot;Properties on '.':\n&quot;, &quot;  svn:ignore\n&quot;, &quot;  svk:merge\n&quot;]</span>
  <span class="ruby-comment">#   [&quot;Properties on 'goruby.c':\n&quot;, &quot;  svn:eol-style\n&quot;]</span>
  <span class="ruby-comment">#   [&quot;Properties on 'complex.c':\n&quot;, &quot;  svn:mime-type\n&quot;, &quot;  svn:eol-style\n&quot;]</span>
  <span class="ruby-comment">#   [&quot;Properties on 'regparse.c':\n&quot;, &quot;  svn:eol-style\n&quot;]</span>
  <span class="ruby-comment">#   ...</span>

<span class="ruby-constant">If</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">block</span> <span class="ruby-identifier">needs</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">maintain</span> <span class="ruby-identifier">state</span> <span class="ruby-identifier">over</span> <span class="ruby-identifier">multiple</span> <span class="ruby-identifier">elements</span>,
<span class="ruby-identifier">local</span> <span class="ruby-identifier">variables</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">used</span>.
<span class="ruby-constant">For</span> <span class="ruby-identifier">example</span>, <span class="ruby-identifier">three</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">more</span> <span class="ruby-identifier">consecutive</span> <span class="ruby-identifier">increasing</span> <span class="ruby-identifier">numbers</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">squashed</span>
<span class="ruby-identifier">as</span> <span class="ruby-identifier">follows</span><span class="ruby-operator">:</span>

  <span class="ruby-identifier">a</span> = [<span class="ruby-value">0</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">6</span>,<span class="ruby-value">7</span>,<span class="ruby-value">9</span>]
  <span class="ruby-identifier">prev</span> = <span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>]
  <span class="ruby-identifier">p</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">slice_before</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">prev</span>, <span class="ruby-identifier">prev2</span> = <span class="ruby-identifier">e</span>, <span class="ruby-identifier">prev</span>
    <span class="ruby-identifier">prev2</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">e</span>
  }.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">es</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">es</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">2</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">es</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;,&quot;</span>) <span class="ruby-operator">:</span> <span class="ruby-node">&quot;#{es.first}-#{es.last}&quot;</span>
  }.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;,&quot;</span>)
  <span class="ruby-comment">#=&gt; &quot;0,2-4,6,7,9&quot;</span>

<span class="ruby-constant">However</span> <span class="ruby-identifier">local</span> <span class="ruby-identifier">variables</span> <span class="ruby-identifier">are</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">appropriate</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">maintain</span> <span class="ruby-identifier">state</span>
<span class="ruby-keyword">if</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">result</span> <span class="ruby-identifier">enumerator</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">used</span> <span class="ruby-identifier">twice</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">more</span>.
<span class="ruby-constant">In</span> <span class="ruby-identifier">such</span> <span class="ruby-keyword">case</span>, <span class="ruby-identifier">the</span> <span class="ruby-identifier">last</span> <span class="ruby-identifier">state</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-value">1</span><span class="ruby-identifier">st</span> <span class="ruby-operator">+</span><span class="ruby-identifier">each</span><span class="ruby-operator">+</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">used</span> <span class="ruby-keyword">in</span> <span class="ruby-value">2</span><span class="ruby-identifier">nd</span> <span class="ruby-operator">+</span><span class="ruby-identifier">each</span><span class="ruby-operator">+</span>.
<span class="ruby-identifier">_initial_state_</span> <span class="ruby-identifier">argument</span> <span class="ruby-identifier">can</span> <span class="ruby-identifier">be</span> <span class="ruby-identifier">used</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">avoid</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">problem</span>.
<span class="ruby-constant">If</span> <span class="ruby-identifier">non</span><span class="ruby-operator">-</span><span class="ruby-keyword">nil</span> <span class="ruby-identifier">value</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">given</span> <span class="ruby-identifier">as</span> <span class="ruby-identifier">_initial_state_</span>,
<span class="ruby-identifier">it</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">duplicated</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">each</span> <span class="ruby-string">&quot;each&quot;</span> <span class="ruby-identifier">method</span> <span class="ruby-identifier">invocation</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">enumerator</span>.
<span class="ruby-constant">The</span> <span class="ruby-identifier">duplicated</span> <span class="ruby-identifier">object</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">passed</span> <span class="ruby-identifier">to</span> <span class="ruby-value">2</span><span class="ruby-identifier">nd</span> <span class="ruby-identifier">argument</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">block</span> <span class="ruby-keyword">for</span>
<span class="ruby-operator">+</span><span class="ruby-identifier">slice_before</span><span class="ruby-operator">+</span> <span class="ruby-identifier">method</span>.

  <span class="ruby-comment"># word wrapping.</span>
  <span class="ruby-comment"># this assumes all characters have same width.</span>
  <span class="ruby-identifier">def</span> <span class="ruby-identifier">wordwrap</span>(<span class="ruby-identifier">words</span>, <span class="ruby-identifier">maxwidth</span>)
    <span class="ruby-comment"># if cols is a local variable, 2nd &quot;each&quot; may start with non-zero cols.</span>
    <span class="ruby-identifier">words</span>.<span class="ruby-identifier">slice_before</span>(<span class="ruby-identifier">cols</span><span class="ruby-operator">:</span> <span class="ruby-value">0</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">w</span>, <span class="ruby-identifier">h</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">h</span>[:<span class="ruby-identifier">cols</span>] <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">h</span>[:<span class="ruby-identifier">cols</span>] <span class="ruby-operator">!=</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">h</span>[:<span class="ruby-identifier">cols</span>] <span class="ruby-operator">+=</span> <span class="ruby-identifier">w</span>.<span class="ruby-identifier">length</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">maxwidth</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">h</span>[:<span class="ruby-identifier">cols</span>]
        <span class="ruby-identifier">h</span>[:<span class="ruby-identifier">cols</span>] = <span class="ruby-identifier">w</span>.<span class="ruby-identifier">length</span>
        <span class="ruby-keyword">true</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">false</span>
      <span class="ruby-keyword">end</span>
    }
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">text</span> = (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">20</span>).<span class="ruby-identifier">to_a</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot; &quot;</span>)
  <span class="ruby-identifier">enum</span> = <span class="ruby-identifier">wordwrap</span>(<span class="ruby-identifier">text</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">%r\s+/</span>), <span class="ruby-value">10</span>)
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;-&quot;</span>*<span class="ruby-value">10</span>
  <span class="ruby-identifier">enum</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">ws</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">ws</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot; &quot;</span>) }
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;-&quot;</span>*<span class="ruby-value">10</span>
  <span class="ruby-comment">#=&gt; ----------</span>
  <span class="ruby-comment">#   1 2 3 4 5</span>
  <span class="ruby-comment">#   6 7 8 9 10</span>
  <span class="ruby-comment">#   11 12 13</span>
  <span class="ruby-comment">#   14 15 16</span>
  <span class="ruby-comment">#   17 18 19</span>
  <span class="ruby-comment">#   20</span>
  <span class="ruby-comment">#   ----------</span>
</pre>

<p>mbox contains series of mails which start with Unix From line. So each mail
can be extracted by slice before Unix From line.</p>

<pre class="ruby"><span class="ruby-comment"># parse mbox</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;mbox&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">line</span>.<span class="ruby-identifier">start_with?</span> <span class="ruby-string">&quot;From &quot;</span>
  }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">mail</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">unix_from</span> = <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">shift</span>
    <span class="ruby-identifier">i</span> = <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&quot;\n&quot;</span>)
    <span class="ruby-identifier">header</span> = <span class="ruby-identifier">mail</span>[<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">i</span>]
    <span class="ruby-identifier">body</span> = <span class="ruby-identifier">mail</span>[(<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)<span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
    <span class="ruby-identifier">body</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">body</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;\n&quot;</span>
    <span class="ruby-identifier">fields</span> = <span class="ruby-identifier">header</span>.<span class="ruby-identifier">slice_before</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-operator">!</span><span class="ruby-string">&quot; \t&quot;</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">line</span>[<span class="ruby-value">0</span>]) }.<span class="ruby-identifier">to_a</span>
    <span class="ruby-identifier">p</span> <span class="ruby-identifier">unix_from</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">fields</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">body</span>
  }
}

<span class="ruby-comment"># split mails in mbox (slice before Unix From line after an empty line)</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;mbox&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">slice_before</span>(<span class="ruby-identifier">emp</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span>,<span class="ruby-identifier">h</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">prevemp</span> = <span class="ruby-identifier">h</span>[:<span class="ruby-identifier">emp</span>]
    <span class="ruby-identifier">h</span>[:<span class="ruby-identifier">emp</span>] = <span class="ruby-identifier">line</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;\n&quot;</span>
    <span class="ruby-identifier">prevemp</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&quot;From &quot;</span>)
  }.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">mail</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">mail</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;\n&quot;</span>
    <span class="ruby-identifier">pp</span> <span class="ruby-identifier">mail</span>
  }
}
</pre>
          

          
          <div class="method-source-code" id="slice_before-source">
            <pre>static VALUE
enum_slice_before(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;

    if (rb_block_given_p()) {
        VALUE initial_state;
        rb_scan_args(argc, argv, &quot;01&quot;, &amp;initial_state);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_sep_pred&quot;), rb_block_proc());
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_initial_state&quot;), initial_state);
    }
    else {
        VALUE sep_pat;
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;sep_pat);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_sep_pat&quot;), sep_pat);
    }
    rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_enumerable&quot;), enumerable);
    rb_block_call(enumerator, rb_intern(&quot;initialize&quot;), 0, 0, slicebefore_i, enumerator);
    return enumerator;
}</pre>
          </div><!-- slice_before-source -->
          
        </div>

        

        
      </div><!-- slice_before-method -->

    
      <div id="method-i-sort" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            sort                     &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            sort {| a, b | block }   &rarr; array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array containing the items in <em>enum</em> sorted, either
according to their own <code>&lt;=&gt;</code> method, or by using the
results of the supplied block. The block should return -1, 0, or +1
depending on the comparison between <em>a</em> and <em>b</em>. As of Ruby
1.8, the method <code>Enumerable#sort_by</code> implements a built-in
Schwartzian Transform, useful when key computation or comparison is
expensive.</p>

<pre class="ruby"><span class="ruby-node">%w(rhea kea flea)</span>.<span class="ruby-identifier">sort</span>         <span class="ruby-comment">#=&gt; [&quot;flea&quot;, &quot;kea&quot;, &quot;rhea&quot;]</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>).<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">a</span>}   <span class="ruby-comment">#=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span>
</pre>
          

          
          <div class="method-source-code" id="sort-source">
            <pre>static VALUE
enum_sort(VALUE obj)
{
    return rb_ary_sort(enum_to_a(0, 0, obj));
}</pre>
          </div><!-- sort-source -->
          
        </div>

        

        
      </div><!-- sort-method -->

    
      <div id="method-i-sort_by" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            sort_by {| obj | block }    &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            sort_by                     &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sorts <em>enum</em> using a set of keys generated by mapping the values in
<em>enum</em> through the given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-node">%w{ apple pear fig }</span>.<span class="ruby-identifier">sort_by</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span>}
              <span class="ruby-comment">#=&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]</span>
</pre>

<p>The current implementation of <code>sort_by</code> generates an array of
tuples containing the original collection element and the mapped value.
This makes <code>sort_by</code> fairly expensive when the keysets are
simple</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'benchmark'</span>

<span class="ruby-identifier">a</span> = (<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">100000</span>).<span class="ruby-identifier">map</span> {<span class="ruby-identifier">rand</span>(<span class="ruby-value">100000</span>)}

<span class="ruby-constant">Benchmark</span>.<span class="ruby-identifier">bm</span>(<span class="ruby-value">10</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">b</span>.<span class="ruby-identifier">report</span>(<span class="ruby-string">&quot;Sort&quot;</span>)    { <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort</span> }
  <span class="ruby-identifier">b</span>.<span class="ruby-identifier">report</span>(<span class="ruby-string">&quot;Sort by&quot;</span>) { <span class="ruby-identifier">a</span>.<span class="ruby-identifier">sort_by</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>} }
<span class="ruby-keyword">end</span>
</pre>

<p><em>produces:</em></p>

<pre>user     system      total        real
Sort        0.180000   0.000000   0.180000 (  0.175469)
Sort by     1.980000   0.040000   2.020000 (  2.013586)</pre>

<p>However, consider the case where comparing the keys is a non-trivial
operation. The following code sorts some files on modification time using
the basic <code>sort</code> method.</p>

<pre class="ruby"><span class="ruby-identifier">files</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">&quot;*&quot;</span>]
<span class="ruby-identifier">sorted</span> = <span class="ruby-identifier">files</span>.<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">a</span>).<span class="ruby-identifier">mtime</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">b</span>).<span class="ruby-identifier">mtime</span>}
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</span>
</pre>

<p>This sort is inefficient: it generates two new <code>File</code> objects
during every comparison. A slightly better technique is to use the
<code>Kernel#test</code> method to generate the modification times
directly.</p>

<pre class="ruby"><span class="ruby-identifier">files</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">&quot;*&quot;</span>]
<span class="ruby-identifier">sorted</span> = <span class="ruby-identifier">files</span>.<span class="ruby-identifier">sort</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">test</span>(<span class="ruby-value">MM</span>, <span class="ruby-identifier">a</span>) <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">test</span>(<span class="ruby-value">MM</span>, <span class="ruby-identifier">b</span>)
}
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</span>
</pre>

<p>This still generates many unnecessary <code>Time</code> objects. A more
efficient technique is to cache the sort keys (modification times in this
case) before the sort. Perl users often call this approach a Schwartzian
Transform, after Randal Schwartz. We construct a temporary array, where
each element is an array containing our sort key along with the filename.
We sort this array, and then extract the filename from the result.</p>

<pre class="ruby"><span class="ruby-identifier">sorted</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">&quot;*&quot;</span>].<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
   [<span class="ruby-identifier">test</span>(<span class="ruby-value">MM</span>, <span class="ruby-identifier">f</span>), <span class="ruby-identifier">f</span>]
}.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-identifier">f</span>[<span class="ruby-value">1</span>] }
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</span>
</pre>

<p>This is exactly what <code>sort_by</code> does internally.</p>

<pre class="ruby"><span class="ruby-identifier">sorted</span> = <span class="ruby-constant">Dir</span>[<span class="ruby-string">&quot;*&quot;</span>].<span class="ruby-identifier">sort_by</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-identifier">test</span>(<span class="ruby-value">MM</span>, <span class="ruby-identifier">f</span>)}
<span class="ruby-identifier">sorted</span>   <span class="ruby-comment">#=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</span>
</pre>
          

          
          <div class="method-source-code" id="sort_by-source">
            <pre>static VALUE
enum_sort_by(VALUE obj)
{
    VALUE ary;
    long i;
    struct sort_by_data data;

    RETURN_ENUMERATOR(obj, 0, 0);

    if (TYPE(obj) == T_ARRAY &amp;&amp; RARRAY_LEN(obj) &lt;= LONG_MAX/2) {
        ary = rb_ary_new2(RARRAY_LEN(obj)*2);
    }
    else {
        ary = rb_ary_new();
    }
    RBASIC(ary)-&gt;klass = 0;
    data.ary = ary;
    data.buf = rb_ary_tmp_new(SORT_BY_BUFSIZE*2);
    data.n = 0;
    rb_ary_store(data.buf, SORT_BY_BUFSIZE*2-1, Qnil);
    rb_block_call(obj, id_each, 0, 0, sort_by_i, (VALUE)&amp;data);
    if (data.n) {
        rb_ary_resize(data.buf, data.n*2);
        rb_ary_concat(ary, data.buf);
    }
    if (RARRAY_LEN(ary) &gt; 2) {
        ruby_qsort(RARRAY_PTR(ary), RARRAY_LEN(ary)/2, 2*sizeof(VALUE),
                   sort_by_cmp, (void *)ary);
    }
    if (RBASIC(ary)-&gt;klass) {
        rb_raise(rb_eRuntimeError, &quot;sort_by reentered&quot;);
    }
    for (i=1; i&lt;RARRAY_LEN(ary); i+=2) {
        RARRAY_PTR(ary)[i/2] = RARRAY_PTR(ary)[i];
    }
    rb_ary_resize(ary, RARRAY_LEN(ary)/2);
    RBASIC(ary)-&gt;klass = rb_cArray;
    OBJ_INFECT(ary, obj);

    return ary;
}</pre>
          </div><!-- sort_by-source -->
          
        </div>

        

        
      </div><!-- sort_by-method -->

    
      <div id="method-i-take" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            take(n)               &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns first n elements from <em>enum</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take</span>(<span class="ruby-value">3</span>)             <span class="ruby-comment">#=&gt; [1, 2, 3]</span>
</pre>
          

          
          <div class="method-source-code" id="take-source">
            <pre>static VALUE
enum_take(VALUE obj, VALUE n)
{
    VALUE args[2];
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }

    if (len == 0) return rb_ary_new2(0);
    args[0] = rb_ary_new();
    args[1] = len;
    rb_block_call(obj, id_each, 0, 0, take_i, (VALUE)args);
    return args[0];
}</pre>
          </div><!-- take-source -->
          
        </div>

        

        
      </div><!-- take-method -->

    
      <div id="method-i-take_while" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            take_while {|arr| block }   &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            take_while                  &rarr; an_enumerator
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Passes elements to the block until the block returns <code>nil</code> or
<code>false</code>, then stops iterating and returns an array of all prior
elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">0</span>]
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">take_while</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> }   <span class="ruby-comment">#=&gt; [1, 2]</span>
</pre>
          

          
          <div class="method-source-code" id="take_while-source">
            <pre>static VALUE
enum_take_while(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);
    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, take_while_i, (VALUE)&amp;ary);
    return ary;
}</pre>
          </div><!-- take_while-source -->
          
        </div>

        

        
      </div><!-- take_while-method -->

    
      <div id="method-i-to_a" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            to_a      &rarr;    array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq" style="background: #cfc;" >
            entries   &rarr;    array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array containing the items in <em>enum</em>.</p>

<pre class="ruby">(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">7</span>).<span class="ruby-identifier">to_a</span>                       <span class="ruby-comment">#=&gt; [1, 2, 3, 4, 5, 6, 7]</span>
{ <span class="ruby-string">'a'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>, <span class="ruby-string">'b'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">2</span>, <span class="ruby-string">'c'</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">3</span> }.<span class="ruby-identifier">to_a</span>   <span class="ruby-comment">#=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]</span>
</pre>
          

          
          <div class="method-source-code" id="to_a-source">
            <pre>static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);
    OBJ_INFECT(ary, obj);

    return ary;
}</pre>
          </div><!-- to_a-source -->
          
        </div>

        

        
      </div><!-- to_a-method -->

    
      <div id="method-i-zip" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq"  >
            zip(arg, ...)                   &rarr; an_array_of_array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq"  >
            zip(arg, ...) {|arr| block }    &rarr; nil
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Takes one element from <em>enum</em> and merges corresponding elements from
each <em>args</em>.  This generates a sequence of <em>n</em>-element
arrays, where <em>n</em> is one more than the count of arguments.  The
length of the resulting sequence will be <code>enum#size</code>.  If the
size of any argument is less than <code>enum#size</code>, <code>nil</code>
values are supplied. If a block is given, it is invoked for each output
array, otherwise an array of arrays is returned.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = [ <span class="ruby-value">4</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span> ]
<span class="ruby-identifier">b</span> = [ <span class="ruby-value">7</span>, <span class="ruby-value">8</span>, <span class="ruby-value">9</span> ]

[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>].<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>)      <span class="ruby-comment">#=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]</span>
[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>].<span class="ruby-identifier">zip</span>(<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>)         <span class="ruby-comment">#=&gt; [[1, 4, 7], [2, 5, 8]]</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">zip</span>([<span class="ruby-value">1</span>,<span class="ruby-value">2</span>],[<span class="ruby-value">8</span>])       <span class="ruby-comment">#=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]</span>
</pre>
          

          
          <div class="method-source-code" id="zip-source">
            <pre>static VALUE
enum_zip(int argc, VALUE *argv, VALUE obj)
{
    int i;
    ID conv;
    NODE *memo;
    VALUE result = Qnil;
    VALUE args = rb_ary_new4(argc, argv);
    int allary = TRUE;

    argv = RARRAY_PTR(args);
    for (i=0; i&lt;argc; i++) {
        VALUE ary = rb_check_array_type(argv[i]);
        if (NIL_P(ary)) {
            allary = FALSE;
            break;
        }
        argv[i] = ary;
    }
    if (!allary) {
        CONST_ID(conv, &quot;to_enum&quot;);
        for (i=0; i&lt;argc; i++) {
            argv[i] = rb_funcall(argv[i], conv, 1, ID2SYM(id_each));
        }
    }
    if (!rb_block_given_p()) {
        result = rb_ary_new();
    }
    /* use NODE_DOT2 as memo(v, v, -) */
    memo = rb_node_newnode(NODE_DOT2, result, args, 0);
    rb_block_call(obj, id_each, 0, 0, allary ? zip_ary : zip_i, (VALUE)memo);

    return result;
}</pre>
          </div><!-- zip-source -->
          
        </div>

        

        
      </div><!-- zip-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

